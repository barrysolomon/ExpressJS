/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var _globalThis$3 = typeof globalThis === 'object'
    ? globalThis
    : typeof self === 'object'
        ? self
        : typeof window === 'object'
            ? window
            : typeof global === 'object'
                ? global
                : {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION$4 = '1.7.0';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([ownVersion]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () { return false; };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4],
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            // cannot parse other version
            // we cannot guarantee compatibility so we always noop
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4],
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor &&
                ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */
var isCompatible = _makeCompatibilityCheck(VERSION$4);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var major = VERSION$4.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global$1 = _globalThis$3;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === void 0) { allowOverride = false; }
    var api = (_global$1[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: VERSION$4,
    });
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION$4) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION$4);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION$4 + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b = _global$1[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION$4 + ".");
    var api = _global$1[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$9 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$4 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */
var DiagComponentLogger = /** @class */ (function () {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}());
function logProxy(funcName, namespace, args) {
    var logger = getGlobal('diag');
    // shortcut if logger not set
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray$4([], __read$9(args), false));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function () { };
    }
    return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$8 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$4 = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */
var DiagAPI = /** @class */ (function () {
    /**
     * Private internal constructor
     * @private
     */
    function DiagAPI() {
        function _logProxy(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal('diag');
                // shortcut if logger not set
                if (!logger)
                    return;
                return logger[funcName].apply(logger, __spreadArray$3([], __read$8(args), false));
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === void 0) { optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }; }
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === 'number') {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel,
                };
            }
            var oldLogger = getGlobal('diag');
            var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
            unregisterGlobal(API_NAME$4, self);
        };
        self.createComponentLogger = function (options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */
    DiagAPI.instance = function () {
        if (!this._instance) {
            this._instance = new DiagAPI();
        }
        return this._instance;
    };
    return DiagAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$7 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values$1 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = /** @class */ (function () {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
            return undefined;
        }
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
            var _b = __read$7(_a, 2), k = _b[0], v = _b[1];
            return [k, v];
        });
    };
    BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
            for (var keys_1 = __values$1(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                newBaggage._entries.delete(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
    };
    return BaggageImpl;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */
var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var diag$1 = DiagAPI.instance();
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
function createBaggage(entries) {
    if (entries === void 0) { entries = {}; }
    return new BaggageImpl(new Map(Object.entries(entries)));
}
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 */
function baggageEntryMetadataFromString(str) {
    if (typeof str !== 'string') {
        diag$1.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
    }
    return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function () {
            return str;
        },
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Get a key to uniquely identify a context value */
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ (function () {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */
    function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) { return self._currentContext.get(key); };
        self.setValue = function (key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function (key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}());
/** The root context is used as the default parent context when there is no active context */
var ROOT_CONTEXT = new BaseContext();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */
var NoopMeter = /** @class */ (function () {
    function NoopMeter() {
    }
    /**
     * @see {@link Meter.createHistogram}
     */
    NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
    };
    /**
     * @see {@link Meter.createCounter}
     */
    NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createUpDownCounter}
     */
    NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableGauge}
     */
    NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createObservableCounter}
     */
    NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableUpDownCounter}
     */
    NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */
    NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) { };
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */
    NoopMeter.prototype.removeBatchObservableCallback = function (_callback) { };
    return NoopMeter;
}());
var NoopMetric = /** @class */ (function () {
    function NoopMetric() {
    }
    return NoopMetric;
}());
var NoopCounterMetric = /** @class */ (function (_super) {
    __extends$3(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopCounterMetric;
}(NoopMetric));
var NoopUpDownCounterMetric = /** @class */ (function (_super) {
    __extends$3(NoopUpDownCounterMetric, _super);
    function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopUpDownCounterMetric;
}(NoopMetric));
var NoopHistogramMetric = /** @class */ (function (_super) {
    __extends$3(NoopHistogramMetric, _super);
    function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric.prototype.record = function (_value, _attributes) { };
    return NoopHistogramMetric;
}(NoopMetric));
var NoopObservableMetric = /** @class */ (function () {
    function NoopObservableMetric() {
    }
    NoopObservableMetric.prototype.addCallback = function (_callback) { };
    NoopObservableMetric.prototype.removeCallback = function (_callback) { };
    return NoopObservableMetric;
}());
var NoopObservableCounterMetric = /** @class */ (function (_super) {
    __extends$3(NoopObservableCounterMetric, _super);
    function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric;
}(NoopObservableMetric));
var NoopObservableGaugeMetric = /** @class */ (function (_super) {
    __extends$3(NoopObservableGaugeMetric, _super);
    function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric;
}(NoopObservableMetric));
var NoopObservableUpDownCounterMetric = /** @class */ (function (_super) {
    __extends$3(NoopObservableUpDownCounterMetric, _super);
    function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric;
}(NoopObservableMetric));
var NOOP_METER = new NoopMeter();
// Synchronous instruments
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
// Asynchronous instruments
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultTextMapGetter = {
    get: function (carrier, key) {
        if (carrier == null) {
            return undefined;
        }
        return carrier[key];
    },
    keys: function (carrier) {
        if (carrier == null) {
            return [];
        }
        return Object.keys(carrier);
    },
};
var defaultTextMapSetter = {
    set: function (carrier, key, value) {
        if (carrier == null) {
            return;
        }
        carrier[key] = value;
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$6 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ (function () {
    function NoopContextManager() {
    }
    NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$2([thisArg], __read$6(args), false));
    };
    NoopContextManager.prototype.bind = function (_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function () {
        return this;
    };
    NoopContextManager.prototype.disable = function () {
        return this;
    };
    return NoopContextManager;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$5 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$3 = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */
var ContextAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function ContextAPI() {
    }
    /** Get the singleton instance of the Context API */
    ContextAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new ContextAPI();
        }
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */
    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
    };
    /**
     * Get the currently active context
     */
    ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray$1([context, fn, thisArg], __read$5(args), false));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */
    ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */
    ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
    };
    return ContextAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Represents no flag set. */
    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE,
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */
var NonRecordingSpan = /** @class */ (function () {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === void 0) { _spanContext = INVALID_SPAN_CONTEXT; }
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function (_endTime) { };
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function () {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
    return NonRecordingSpan;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * span key
 */
var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
/**
 * Gets the span from the current context, if one exists.
 */
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */
function isSpanContextValid(spanContext) {
    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
}
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var contextApi = ContextAPI.getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */
var NoopTracer = /** @class */ (function () {
    function NoopTracer() {
    }
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === void 0) { context = contextApi.active(); }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) &&
            isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        }
        else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}());
function isSpanContext(spanContext) {
    return (typeof spanContext === 'object' &&
        typeof spanContext['spanId'] === 'string' &&
        typeof spanContext['traceId'] === 'string' &&
        typeof spanContext['traceFlags'] === 'number');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER = new NoopTracer();
/**
 * Proxy tracer provided by the proxy tracer provider
 */
var ProxyTracer = /** @class */ (function () {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */
    ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */
var NoopTracerProvider = /** @class */ (function () {
    function NoopTracerProvider() {
    }
    NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */
var ProxyTracerProvider = /** @class */ (function () {
    function ProxyTracerProvider() {
    }
    /**
     * Get a {@link ProxyTracer}
     */
    ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options));
    };
    ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */
    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision$1;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision$1 || (SamplingDecision$1 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

/**
 * An enumeration of status codes.
 */
var SpanStatusCode;
(function (SpanStatusCode) {
    /**
     * The default status.
     */
    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */
    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for context API */
var context = ContextAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 */
var diag = DiagAPI.instance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */
var NoopMeterProvider = /** @class */ (function () {
    function NoopMeterProvider() {
    }
    NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
    };
    return NoopMeterProvider;
}());
var NOOP_METER_PROVIDER = new NoopMeterProvider();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$2 = 'metrics';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */
var MetricsAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function MetricsAPI() {
    }
    /** Get the singleton instance of the Metrics API */
    MetricsAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new MetricsAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global meter provider.
     * Returns true if the meter provider was successfully registered, else false.
     */
    MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
    };
    /**
     * Returns the global meter provider.
     */
    MetricsAPI.prototype.getMeterProvider = function () {
        return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
    };
    /**
     * Returns a meter from the global meter provider.
     */
    MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
    };
    /** Remove the global meter provider */
    MetricsAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$2, DiagAPI.instance());
    };
    return MetricsAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for metrics API */
var metrics = MetricsAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * No-op implementations of {@link TextMapPropagator}.
 */
var NoopTextMapPropagator = /** @class */ (function () {
    function NoopTextMapPropagator() {
    }
    /** Noop inject function does nothing */
    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
    /** Noop extract function does nothing and returns the input context */
    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function () {
        return [];
    };
    return NoopTextMapPropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Baggage key
 */
var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */
function getActiveBaggage() {
    return getBaggage(ContextAPI.getInstance().active());
}
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$1 = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */
var PropagationAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
    }
    /** Get the singleton instance of the Propagator API */
    PropagationAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new PropagationAPI();
        }
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */
    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */
    PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === void 0) { setter = defaultTextMapSetter; }
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */
    PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === void 0) { getter = defaultTextMapGetter; }
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */
    PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */
    PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for propagation API */
var propagation = PropagationAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */
var TraceAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    /** Get the singleton instance of the Trace API */
    TraceAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new TraceAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */
    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    /**
     * Returns the global tracer provider.
     */
    TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */
    TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */
    TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for trace API */
var trace = TraceAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BAGGAGE_KEY_PAIR_SEPARATOR$1 = '=';
const BAGGAGE_PROPERTIES_SEPARATOR$1 = ';';
const BAGGAGE_ITEMS_SEPARATOR$1 = ',';
// Name of the http header used to propagate the baggage
const BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
const BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
const BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
const BAGGAGE_MAX_TOTAL_LENGTH = 8192;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR$1 : ''}${current}`;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += BAGGAGE_PROPERTIES_SEPARATOR$1 + value.metadata.toString();
        }
        return entry;
    });
}
function parsePairKeyValue$1(entry) {
    const valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR$1);
    if (valueProps.length <= 0)
        return;
    const keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR$1);
    if (separatorIndex <= 0)
        return;
    const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    let metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR$1));
    }
    return { key, value, metadata };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
class W3CBaggagePropagator {
    inject(context, carrier, setter) {
        const baggage = propagation.getBaggage(context);
        if (!baggage || isTracingSuppressed(context))
            return;
        const keyPairs = getKeyPairs(baggage)
            .filter((pair) => {
            return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
    }
    extract(context, carrier, getter) {
        const headerValue = getter.get(carrier, BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue)
            ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR$1)
            : headerValue;
        if (!baggageString)
            return context;
        const baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        const pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR$1);
        pairs.forEach(entry => {
            const keyPair = parsePairKeyValue$1(entry);
            if (keyPair) {
                const baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    }
    fields() {
        return [BAGGAGE_HEADER];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function sanitizeAttributes(attributes) {
    const out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
            diag.warn(`Invalid attribute key: ${key}`);
            continue;
        }
        if (!isAttributeValue(val)) {
            diag.warn(`Invalid attribute value set for key: ${key}`);
            continue;
        }
        if (Array.isArray(val)) {
            out[key] = val.slice();
        }
        else {
            out[key] = val;
        }
    }
    return out;
}
function isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
    }
    return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
    let type;
    for (const element of arr) {
        // null/undefined elements are allowed
        if (element == null)
            continue;
        if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
                type = typeof element;
                continue;
            }
            // encountered an invalid primitive
            return false;
        }
        if (typeof element === type) {
            continue;
        }
        return false;
    }
    return true;
}
function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function loggingErrorHandler() {
    return (ex) => {
        diag.error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function flattenException(ex) {
    const result = {};
    let current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(propertyName => {
            if (result[propertyName])
                return;
            const value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The global error handler delegate */
let delegateHandler = loggingErrorHandler();
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    }
    catch { } // eslint-disable-line no-empty
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getNumberFromEnv(_) {
    return undefined;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const otperformance$4 = performance;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
const VERSION$3 = '2.0.1';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TMP_HTTP_URL = 'http.url';
const TMP_HTTP_USER_AGENT = 'http.user_agent';
/**
 * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
 *
 * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
 *
 * @deprecated Use ATTR_HTTP_URL in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
 */
const SEMATTRS_HTTP_URL = TMP_HTTP_URL;
/**
 * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
 *
 * @deprecated Use ATTR_HTTP_USER_AGENT in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
 */
const SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * ASP.NET Core exception middleware handling result
 *
 * @example handled
 * @example unhandled
 */
/**
 * Describes a class of error the operation ended with.
 *
 * @example timeout
 * @example java.net.UnknownHostException
 * @example server_certificate_invalid
 * @example 500
 *
 * @note The `error.type` **SHOULD** be predictable, and **SHOULD** have low cardinality.
 *
 * When `error.type` is set to a type (e.g., an exception type), its
 * canonical class name identifying the type within the artifact **SHOULD** be used.
 *
 * Instrumentations **SHOULD** document the list of errors they report.
 *
 * The cardinality of `error.type` within one instrumentation library **SHOULD** be low.
 * Telemetry consumers that aggregate data from multiple instrumentation libraries and applications
 * should be prepared for `error.type` to have high cardinality at query time when no
 * additional filters are applied.
 *
 * If the operation has completed successfully, instrumentations **SHOULD NOT** set `error.type`.
 *
 * If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),
 * it's **RECOMMENDED** to:
 *
 *   - Use a domain-specific attribute
 *   - Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.
 */
const ATTR_ERROR_TYPE = 'error.type';
/**
 * The exception message.
 *
 * @example Division by zero
 * @example Can't convert 'int' object to str implicitly
 */
const ATTR_EXCEPTION_MESSAGE = 'exception.message';
/**
 * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
 *
 * @example "Exception in thread "main" java.lang.RuntimeException: Test exception\\n at com.example.GenerateTrace.methodB(GenerateTrace.java:13)\\n at com.example.GenerateTrace.methodA(GenerateTrace.java:9)\\n at com.example.GenerateTrace.main(GenerateTrace.java:5)\\n"
 */
const ATTR_EXCEPTION_STACKTRACE = 'exception.stacktrace';
/**
 * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
 *
 * @example java.net.ConnectException
 * @example OSError
 */
const ATTR_EXCEPTION_TYPE = 'exception.type';
/**
 * HTTP request method.
 *
 * @example GET
 * @example POST
 * @example HEAD
 *
 * @note HTTP request method value **SHOULD** be "known" to the instrumentation.
 * By default, this convention defines "known" methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)
 * and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).
 *
 * If the HTTP request method is not known to instrumentation, it **MUST** set the `http.request.method` attribute to `_OTHER`.
 *
 * If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it **MUST** provide a way to override
 * the list of known HTTP methods. If this override is done via environment variable, then the environment variable **MUST** be named
 * OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods
 * (this list **MUST** be a full override of the default known method, it is not a list of known methods in addition to the defaults).
 *
 * HTTP method names are case-sensitive and `http.request.method` attribute value **MUST** match a known HTTP method name exactly.
 * Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, **SHOULD** populate a canonical equivalent.
 * Tracing instrumentations that do so, **MUST** also set `http.request.method_original` to the original value.
 */
const ATTR_HTTP_REQUEST_METHOD = 'http.request.method';
/**
 * Original HTTP method sent by the client in the request line.
 *
 * @example GeT
 * @example ACL
 * @example foo
 */
const ATTR_HTTP_REQUEST_METHOD_ORIGINAL = 'http.request.method_original';
/**
 * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
 *
 * @example 200
 */
const ATTR_HTTP_RESPONSE_STATUS_CODE = 'http.response.status_code';
/**
 * Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name.
 *
 * @example example.com
 * @example 10.1.2.80
 * @example /tmp/my.sock
 *
 * @note When observed from the client side, and when communicating through an intermediary, `server.address` **SHOULD** represent the server address behind any intermediaries, for example proxies, if it's available.
 */
const ATTR_SERVER_ADDRESS = 'server.address';
/**
 * Server port number.
 *
 * @example 80
 * @example 8080
 * @example 443
 *
 * @note When observed from the client side, and when communicating through an intermediary, `server.port` **SHOULD** represent the server port behind any intermediaries, for example proxies, if it's available.
 */
const ATTR_SERVER_PORT = 'server.port';
/**
 * Logical name of the service.
 *
 * @example shoppingcart
 *
 * @note **MUST** be the same for all instances of horizontally scaled services. If the value was not specified, SDKs **MUST** fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value **MUST** be set to `unknown_service`.
 */
const ATTR_SERVICE_NAME = 'service.name';
/**
 * The version string of the service API or implementation. The format is not defined by these conventions.
 *
 * @example 2.0.0
 * @example a01dbef8a
 */
const ATTR_SERVICE_VERSION = 'service.version';
/**
 * The language of the telemetry SDK.
 */
const ATTR_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
/**
  * Enum value "webjs" for attribute {@link ATTR_TELEMETRY_SDK_LANGUAGE}.
  */
const TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
/**
 * The name of the telemetry SDK as defined above.
 *
 * @example opentelemetry
 *
 * @note The OpenTelemetry SDK **MUST** set the `telemetry.sdk.name` attribute to `opentelemetry`.
 * If another SDK, like a fork or a vendor-provided implementation, is used, this SDK **MUST** set the
 * `telemetry.sdk.name` attribute to the fully-qualified class or module name of this SDK's main entry point
 * or another suitable identifier depending on the language.
 * The identifier `opentelemetry` is reserved and **MUST NOT** be used in this case.
 * All custom identifiers **SHOULD** be stable across different versions of an implementation.
 */
const ATTR_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
/**
 * The version string of the telemetry SDK.
 *
 * @example 1.2.3
 */
const ATTR_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
/**
 * Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986)
 *
 * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv
 * @example //localhost
 *
 * @note For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment
 * is not transmitted over HTTP, but if it is known, it **SHOULD** be included nevertheless.
 *
 * `url.full` **MUST NOT** contain credentials passed via URL in form of `https://username:password@www.example.com/`.
 * In such case username and password **SHOULD** be redacted and attribute's value **SHOULD** be `https://REDACTED:REDACTED@www.example.com/`.
 *
 * `url.full` **SHOULD** capture the absolute URL when it is available (or can be reconstructed).
 *
 * Sensitive content provided in `url.full` **SHOULD** be scrubbed when instrumentations can identify it.
 *
 *
 * Query string values for the following keys **SHOULD** be redacted by default and replaced by the
 * value `REDACTED`:
 *
 *   - [`AWSAccessKeyId`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
 *   - [`Signature`](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RESTAuthentication.html#RESTAuthenticationQueryStringAuth)
 *   - [`sig`](https://learn.microsoft.com/azure/storage/common/storage-sas-overview#sas-token)
 *   - [`X-Goog-Signature`](https://cloud.google.com/storage/docs/access-control/signed-urls)
 *
 * This list is subject to change over time.
 *
 * When a query string value is redacted, the query string key **SHOULD** still be preserved, e.g.
 * `https://www.example.com/path?color=blue&sig=REDACTED`.
 */
const ATTR_URL_FULL = 'url.full';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file contains a copy of unstable semantic convention definitions
 * used by this package.
 * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv
 */
/**
 * The name of the runtime of this process.
 *
 * @example OpenJDK Runtime Environment
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
const ATTR_PROCESS_RUNTIME_NAME = 'process.runtime.name';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Constants describing the SDK in use */
const SDK_INFO = {
    [ATTR_TELEMETRY_SDK_NAME]: 'opentelemetry',
    [ATTR_PROCESS_RUNTIME_NAME]: 'browser',
    [ATTR_TELEMETRY_SDK_LANGUAGE]: TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
    [ATTR_TELEMETRY_SDK_VERSION]: VERSION$3,
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unrefTimer(_timer) { }

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NANOSECOND_DIGITS$4 = 9;
const NANOSECOND_DIGITS_IN_MILLIS$3 = 6;
const MILLISECONDS_TO_NANOSECONDS$3 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS$3);
const SECOND_TO_NANOSECONDS$4 = Math.pow(10, NANOSECOND_DIGITS$4);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */
function millisToHrTime$3(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    // Decimals only.
    const seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS$3);
    return [seconds, nanos];
}
function getTimeOrigin$3() {
    let timeOrigin = otperformance$4.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        const perf = otperformance$4;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime$3(performanceNow) {
    const timeOrigin = millisToHrTime$3(getTimeOrigin$3());
    const now = millisToHrTime$3(typeof performanceNow === 'number' ? performanceNow : otperformance$4.now());
    return addHrTimes$3(timeOrigin, now);
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin$3()) {
            return hrTime$3(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return millisToHrTime$3(time);
        }
    }
    else if (time instanceof Date) {
        return millisToHrTime$3(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function hrTimeDuration(startTime, endTime) {
    let seconds = endTime[0] - startTime[0];
    let nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS$4;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function hrTimeToNanoseconds$1(time) {
    return time[0] * SECOND_TO_NANOSECONDS$4 + time[1];
}
/**
 * check if time is HrTime
 * @param value
 */
function isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function isTimeInput(value) {
    return (isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */
function addHrTimes$3(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS$4) {
        out[1] -= SECOND_TO_NANOSECONDS$4;
        out[0] += 1;
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExportResultCode$1;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode$1 || (ExportResultCode$1 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Combines multiple propagators into a single propagator. */
class CompositePropagator {
    _propagators;
    _fields;
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    constructor(config = {}) {
        this._propagators = config.propagators ?? [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(p => (typeof p.fields === 'function' ? p.fields() : []))
            .reduce((x, y) => x.concat(y), [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    inject(context, carrier, setter) {
        for (const propagator of this._propagators) {
            try {
                propagator.inject(context, carrier, setter);
            }
            catch (err) {
                diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
            }
        }
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    extract(context, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
            }
            return ctx;
        }, context);
    }
    fields() {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
const VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
const VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
const VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
const VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
const INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function validateValue(value) {
    return (VALID_VALUE_BASE_REGEX.test(value) &&
        !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_TRACE_STATE_ITEMS = 32;
const MAX_TRACE_STATE_LEN = 512;
const LIST_MEMBERS_SEPARATOR = ',';
const LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
class TraceState {
    _internalState = new Map();
    constructor(rawTraceState) {
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    set(key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    }
    unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    }
    get(key) {
        return this._internalState.get(key);
    }
    serialize() {
        return this._keys()
            .reduce((agg, key) => {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
            return agg;
        }, [])
            .join(LIST_MEMBERS_SEPARATOR);
    }
    _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce((agg, part) => {
            const listMember = part.trim(); // Optional Whitespace (OWS) handling
            const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                const key = listMember.slice(0, i);
                const value = listMember.slice(i + 1, part.length);
                if (validateKey(key) && validateValue(value)) {
                    agg.set(key, value);
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, MAX_TRACE_STATE_ITEMS));
        }
    }
    _keys() {
        return Array.from(this._internalState.keys()).reverse();
    }
    _clone() {
        const traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TRACE_PARENT_HEADER$1 = 'traceparent';
const TRACE_STATE_HEADER = 'tracestate';
const VERSION$2 = '00';
const VERSION_PART = '(?!ff)[\\da-f]{2}';
const TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
const PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
const FLAGS_PART = '[\\da-f]{2}';
const TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function parseTraceParent(traceParent) {
    const match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
class W3CTraceContextPropagator {
    inject(context, carrier, setter) {
        const spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        const traceParent = `${VERSION$2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, TRACE_PARENT_HEADER$1, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    }
    extract(context, carrier, getter) {
        const traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER$1);
        if (!traceParentHeader)
            return context;
        const traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            const state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    }
    fields() {
        return [TRACE_PARENT_HEADER$1, TRACE_STATE_HEADER];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
const objectTag = '[object Object]';
const nullTag = '[object Null]';
const undefinedTag = '[object Undefined]';
const funcProto = Function.prototype;
const funcToString = funcProto.toString;
const objectCtorString = funcToString.call(Object);
const getPrototypeOf = Object.getPrototypeOf;
const objectProto = Object.prototype;
const hasOwnProperty = objectProto.hasOwnProperty;
const symToStringTag = Symbol ? Symbol.toStringTag : undefined;
const nativeObjectToString = objectProto.toString;
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
    }
    const proto = getPrototypeOf(value);
    if (proto === null) {
        return true;
    }
    const Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (typeof Ctor == 'function' &&
        Ctor instanceof Ctor &&
        funcToString.call(Ctor) === objectCtorString);
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
        ? getRawTag(value)
        : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
    const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    let unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    const result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
    return nativeObjectToString.call(value);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
const MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function merge(...args) {
    let result = args.shift();
    const objects = new WeakMap();
    while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function takeValue(value) {
    if (isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function mergeTwoObjects(one, two, level = 0, objects) {
    let result;
    if (level > MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
    }
    else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
            for (let i = 0, j = two.length; i < j; i++) {
                result.push(takeValue(two[i]));
            }
        }
        else if (isObject(two)) {
            const keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
                const key = keys[i];
                result[key] = takeValue(two[key]);
            }
        }
    }
    else if (isObject(one)) {
        if (isObject(two)) {
            if (!shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            const keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
                const key = keys[i];
                const twoValue = two[key];
                if (isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    const obj1 = result[key];
                    const obj2 = twoValue;
                    if (wasObjectReferenced(one, key, objects) ||
                        wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (isObject(obj1) && isObject(obj2)) {
                            const arr1 = objects.get(obj1) || [];
                            const arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key });
                            arr2.push({ obj: two, key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function wasObjectReferenced(obj, key, objects) {
    const arr = objects.get(obj[key]) || [];
    for (let i = 0, j = arr.length; i < j; i++) {
        const info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return (!isPrimitive(value) &&
        !isArray(value) &&
        !isFunction(value) &&
        typeof value === 'object');
}
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null);
}
function shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlMatches$2(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Deferred$1 = class Deferred {
    _promise;
    _resolve;
    _reject;
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    get promise() {
        return this._promise;
    }
    resolve(val) {
        this._resolve(val);
    }
    reject(err) {
        this._reject(err);
    }
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
let BindOnceFuture$1 = class BindOnceFuture {
    _callback;
    _that;
    _isCalled = false;
    _deferred = new Deferred$1();
    constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
    }
    get isCalled() {
        return this._isCalled;
    }
    get promise() {
        return this._deferred.promise;
    }
    call(...args) {
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve(this._callback.call(this._that, ...args)).then(val => this._deferred.resolve(val), err => this._deferred.reject(err));
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    }
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defaultServiceName() {
    return 'unknown_service';
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const isPromiseLike = (val) => {
    return (val !== null &&
        typeof val === 'object' &&
        typeof val.then === 'function');
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ResourceImpl {
    _rawAttributes;
    _asyncAttributesPending = false;
    _memoizedAttributes;
    static FromAttributeList(attributes) {
        const res = new ResourceImpl({});
        res._rawAttributes = guardedRawAttributes(attributes);
        res._asyncAttributesPending =
            attributes.filter(([_, val]) => isPromiseLike(val)).length > 0;
        return res;
    }
    constructor(
    /**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */
    resource) {
        const attributes = resource.attributes ?? {};
        this._rawAttributes = Object.entries(attributes).map(([k, v]) => {
            if (isPromiseLike(v)) {
                // side-effect
                this._asyncAttributesPending = true;
            }
            return [k, v];
        });
        this._rawAttributes = guardedRawAttributes(this._rawAttributes);
    }
    get asyncAttributesPending() {
        return this._asyncAttributesPending;
    }
    async waitForAsyncAttributes() {
        if (!this.asyncAttributesPending) {
            return;
        }
        for (let i = 0; i < this._rawAttributes.length; i++) {
            const [k, v] = this._rawAttributes[i];
            this._rawAttributes[i] = [k, isPromiseLike(v) ? await v : v];
        }
        this._asyncAttributesPending = false;
    }
    get attributes() {
        if (this.asyncAttributesPending) {
            diag.error('Accessing resource attributes before async attributes settled');
        }
        if (this._memoizedAttributes) {
            return this._memoizedAttributes;
        }
        const attrs = {};
        for (const [k, v] of this._rawAttributes) {
            if (isPromiseLike(v)) {
                diag.debug(`Unsettled resource attribute ${k} skipped`);
                continue;
            }
            if (v != null) {
                attrs[k] ??= v;
            }
        }
        // only memoize output if all attributes are settled
        if (!this._asyncAttributesPending) {
            this._memoizedAttributes = attrs;
        }
        return attrs;
    }
    getRawAttributes() {
        return this._rawAttributes;
    }
    merge(resource) {
        if (resource == null)
            return this;
        // Order is important
        // Spec states incoming attributes override existing attributes
        return ResourceImpl.FromAttributeList([
            ...resource.getRawAttributes(),
            ...this.getRawAttributes(),
        ]);
    }
}
function resourceFromAttributes(attributes) {
    return ResourceImpl.FromAttributeList(Object.entries(attributes));
}
function defaultResource() {
    return resourceFromAttributes({
        [ATTR_SERVICE_NAME]: defaultServiceName(),
        [ATTR_TELEMETRY_SDK_LANGUAGE]: SDK_INFO[ATTR_TELEMETRY_SDK_LANGUAGE],
        [ATTR_TELEMETRY_SDK_NAME]: SDK_INFO[ATTR_TELEMETRY_SDK_NAME],
        [ATTR_TELEMETRY_SDK_VERSION]: SDK_INFO[ATTR_TELEMETRY_SDK_VERSION],
    });
}
function guardedRawAttributes(attributes) {
    return attributes.map(([k, v]) => {
        if (isPromiseLike(v)) {
            return [
                k,
                v.catch(err => {
                    diag.debug('promise rejection for resource attribute: %s - %s', k, err);
                    return undefined;
                }),
            ];
        }
        return [k, v];
    });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Event name definitions
const ExceptionEventName = 'exception';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class represents a span.
 */
class SpanImpl {
    // Below properties are included to implement ReadableSpan for export
    // purposes but are not intended to be written-to directly.
    _spanContext;
    kind;
    parentSpanContext;
    attributes = {};
    links = [];
    events = [];
    startTime;
    resource;
    instrumentationScope;
    _droppedAttributesCount = 0;
    _droppedEventsCount = 0;
    _droppedLinksCount = 0;
    name;
    status = {
        code: SpanStatusCode.UNSET,
    };
    endTime = [0, 0];
    _ended = false;
    _duration = [-1, -1];
    _spanProcessor;
    _spanLimits;
    _attributeValueLengthLimit;
    _performanceStartTime;
    _performanceOffset;
    _startTimeProvided;
    /**
     * Constructs a new SpanImpl instance.
     */
    constructor(opts) {
        const now = Date.now();
        this._spanContext = opts.spanContext;
        this._performanceStartTime = otperformance$4.now();
        this._performanceOffset =
            now - (this._performanceStartTime + getTimeOrigin$3());
        this._startTimeProvided = opts.startTime != null;
        this._spanLimits = opts.spanLimits;
        this._attributeValueLengthLimit =
            this._spanLimits.attributeValueLengthLimit || 0;
        this._spanProcessor = opts.spanProcessor;
        this.name = opts.name;
        this.parentSpanContext = opts.parentSpanContext;
        this.kind = opts.kind;
        this.links = opts.links || [];
        this.startTime = this._getTime(opts.startTime ?? now);
        this.resource = opts.resource;
        this.instrumentationScope = opts.scope;
        if (opts.attributes != null) {
            this.setAttributes(opts.attributes);
        }
        this._spanProcessor.onStart(this, opts.context);
    }
    spanContext() {
        return this._spanContext;
    }
    setAttribute(key, value) {
        if (value == null || this._isSpanEnded())
            return this;
        if (key.length === 0) {
            diag.warn(`Invalid attribute key: ${key}`);
            return this;
        }
        if (!isAttributeValue(value)) {
            diag.warn(`Invalid attribute value set for key: ${key}`);
            return this;
        }
        const { attributeCountLimit } = this._spanLimits;
        if (attributeCountLimit !== undefined &&
            Object.keys(this.attributes).length >= attributeCountLimit &&
            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
            this._droppedAttributesCount++;
            return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
    }
    setAttributes(attributes) {
        for (const [k, v] of Object.entries(attributes)) {
            this.setAttribute(k, v);
        }
        return this;
    }
    /**
     *
     * @param name Span Name
     * @param [attributesOrStartTime] Span attributes or start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [timeStamp] Specified time stamp for the event
     */
    addEvent(name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded())
            return this;
        const { eventCountLimit } = this._spanLimits;
        if (eventCountLimit === 0) {
            diag.warn('No events allowed.');
            this._droppedEventsCount++;
            return this;
        }
        if (eventCountLimit !== undefined &&
            this.events.length >= eventCountLimit) {
            if (this._droppedEventsCount === 0) {
                diag.debug('Dropping extra events.');
            }
            this.events.shift();
            this._droppedEventsCount++;
        }
        if (isTimeInput(attributesOrStartTime)) {
            if (!isTimeInput(timeStamp)) {
                timeStamp = attributesOrStartTime;
            }
            attributesOrStartTime = undefined;
        }
        const attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
            name,
            attributes,
            time: this._getTime(timeStamp),
            droppedAttributesCount: 0,
        });
        return this;
    }
    addLink(link) {
        this.links.push(link);
        return this;
    }
    addLinks(links) {
        this.links.push(...links);
        return this;
    }
    setStatus(status) {
        if (this._isSpanEnded())
            return this;
        this.status = { ...status };
        // When using try-catch, the caught "error" is of type `any`. When then assigning `any` to `status.message`,
        // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()
        // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or
        // undefined to avoid an incorrect type causing issues downstream.
        if (this.status.message != null && typeof status.message !== 'string') {
            diag.warn(`Dropping invalid status.message of type '${typeof status.message}', expected 'string'`);
            delete this.status.message;
        }
        return this;
    }
    updateName(name) {
        if (this._isSpanEnded())
            return this;
        this.name = name;
        return this;
    }
    end(endTime) {
        if (this._isSpanEnded()) {
            diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
            return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
            diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
            this.endTime = this.startTime.slice();
            this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
            diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
        }
        this._spanProcessor.onEnd(this);
    }
    _getTime(inp) {
        if (typeof inp === 'number' && inp <= otperformance$4.now()) {
            // must be a performance timestamp
            // apply correction and convert to hrtime
            return hrTime$3(inp + this._performanceOffset);
        }
        if (typeof inp === 'number') {
            return millisToHrTime$3(inp);
        }
        if (inp instanceof Date) {
            return millisToHrTime$3(inp.getTime());
        }
        if (isTimeInputHrTime(inp)) {
            return inp;
        }
        if (this._startTimeProvided) {
            // if user provided a time for the start manually
            // we can't use duration to calculate event/end times
            return millisToHrTime$3(Date.now());
        }
        const msDuration = otperformance$4.now() - this._performanceStartTime;
        return addHrTimes$3(this.startTime, millisToHrTime$3(msDuration));
    }
    isRecording() {
        return this._ended === false;
    }
    recordException(exception, time) {
        const attributes = {};
        if (typeof exception === 'string') {
            attributes[ATTR_EXCEPTION_MESSAGE] = exception;
        }
        else if (exception) {
            if (exception.code) {
                attributes[ATTR_EXCEPTION_TYPE] = exception.code.toString();
            }
            else if (exception.name) {
                attributes[ATTR_EXCEPTION_TYPE] = exception.name;
            }
            if (exception.message) {
                attributes[ATTR_EXCEPTION_MESSAGE] = exception.message;
            }
            if (exception.stack) {
                attributes[ATTR_EXCEPTION_STACKTRACE] = exception.stack;
            }
        }
        // these are minimum requirements from spec
        if (attributes[ATTR_EXCEPTION_TYPE] || attributes[ATTR_EXCEPTION_MESSAGE]) {
            this.addEvent(ExceptionEventName, attributes, time);
        }
        else {
            diag.warn(`Failed to record an exception ${exception}`);
        }
    }
    get duration() {
        return this._duration;
    }
    get ended() {
        return this._ended;
    }
    get droppedAttributesCount() {
        return this._droppedAttributesCount;
    }
    get droppedEventsCount() {
        return this._droppedEventsCount;
    }
    get droppedLinksCount() {
        return this._droppedLinksCount;
    }
    _isSpanEnded() {
        if (this._ended) {
            const error = new Error(`Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
            diag.warn(`Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`, error);
        }
        return this._ended;
    }
    // Utility function to truncate given value within size
    // for value type of string, will truncate to given limit
    // for type of non-string, will return same value
    _truncateToLimitUtil(value, limit) {
        if (value.length <= limit) {
            return value;
        }
        return value.substring(0, limit);
    }
    /**
     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
     * return string with truncated to {@code attributeValueLengthLimit} characters
     *
     * If the given attribute value is array of strings then
     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
     *
     * Otherwise return same Attribute {@code value}
     *
     * @param value Attribute value
     * @returns truncated attribute value if required, otherwise same value
     */
    _truncateToSize(value) {
        const limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
            // Negative values are invalid, so do not truncate
            diag.warn(`Attribute value limit must be positive, got ${limit}`);
            return value;
        }
        // String
        if (typeof value === 'string') {
            return this._truncateToLimitUtil(value, limit);
        }
        // Array of strings
        if (Array.isArray(value)) {
            return value.map(val => typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val);
        }
        // Other types, no need to apply value length limit
        return value;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples no traces. */
class AlwaysOffSampler {
    shouldSample() {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    }
    toString() {
        return 'AlwaysOffSampler';
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples all traces. */
class AlwaysOnSampler {
    shouldSample() {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    }
    toString() {
        return 'AlwaysOnSampler';
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
class ParentBasedSampler {
    _root;
    _remoteParentSampled;
    _remoteParentNotSampled;
    _localParentSampled;
    _localParentNotSampled;
    constructor(config) {
        this._root = config.root;
        if (!this._root) {
            globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled =
            config.remoteParentSampled ?? new AlwaysOnSampler();
        this._remoteParentNotSampled =
            config.remoteParentNotSampled ?? new AlwaysOffSampler();
        this._localParentSampled =
            config.localParentSampled ?? new AlwaysOnSampler();
        this._localParentNotSampled =
            config.localParentNotSampled ?? new AlwaysOffSampler();
    }
    shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    }
    toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples a given fraction of traces based of trace id deterministically. */
class TraceIdRatioBasedSampler {
    _ratio;
    _upperBound;
    constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    shouldSample(context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    }
    toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
    }
    _normalize(ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    }
    _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
            const pos = i * 8;
            const part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_RATIO = 1;
/**
 * Load default configuration. For fields with primitive values, any user-provided
 * value will override the corresponding default value. For fields with
 * non-primitive values (like `spanLimits`), the user-provided value will be
 * used to extend the default value.
 */
// object needs to be wrapped in this function and called when needed otherwise
// envs are parsed before tests are ran - causes tests using these envs to fail
function loadDefaultConfig() {
    return {
        sampler: buildSamplerFromEnv(),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
            attributeValueLengthLimit: Infinity,
            attributeCountLimit: 128,
        },
        spanLimits: {
            attributeValueLengthLimit: Infinity,
            attributeCountLimit: 128,
            linkCountLimit: 128,
            eventCountLimit: 128,
            attributePerEventCountLimit: 128,
            attributePerLinkCountLimit: 128,
        },
    };
}
/**
 * Based on environment, builds a sampler, complies with specification.
 */
function buildSamplerFromEnv() {
    const sampler = "parentbased_always_on" /* TracesSamplerValues.ParentBasedAlwaysOn */;
    switch (sampler) {
        case "always_on" /* TracesSamplerValues.AlwaysOn */:
            return new AlwaysOnSampler();
        case "always_off" /* TracesSamplerValues.AlwaysOff */:
            return new AlwaysOffSampler();
        case "parentbased_always_on" /* TracesSamplerValues.ParentBasedAlwaysOn */:
            return new ParentBasedSampler({
                root: new AlwaysOnSampler(),
            });
        case "parentbased_always_off" /* TracesSamplerValues.ParentBasedAlwaysOff */:
            return new ParentBasedSampler({
                root: new AlwaysOffSampler(),
            });
        case "traceidratio" /* TracesSamplerValues.TraceIdRatio */:
            return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv());
        case "parentbased_traceidratio" /* TracesSamplerValues.ParentBasedTraceIdRatio */:
            return new ParentBasedSampler({
                root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv()),
            });
        default:
            diag.error(`OTEL_TRACES_SAMPLER value "${sampler}" invalid, defaulting to "${"parentbased_always_on" /* TracesSamplerValues.ParentBasedAlwaysOn */}".`);
            return new ParentBasedSampler({
                root: new AlwaysOnSampler(),
            });
    }
}
function getSamplerProbabilityFromEnv() {
    {
        diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ATTRIBUTE_COUNT_LIMIT$1 = 128;
const DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT$1 = Infinity;
/**
 * Function to merge Default configuration (as specified in './config') with
 * user provided configurations.
 */
function mergeConfig(userConfig) {
    const perInstanceDefaults = {
        sampler: buildSamplerFromEnv(),
    };
    const DEFAULT_CONFIG = loadDefaultConfig();
    const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
}
/**
 * When general limits are provided and model specific limits are not,
 * configures the model specific limits by using the values from the general ones.
 * @param userConfig User provided tracer configuration
 */
function reconfigureLimits(userConfig) {
    const spanLimits = Object.assign({}, userConfig.spanLimits);
    /**
     * Reassign span attribute count limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeCountLimit =
        userConfig.spanLimits?.attributeCountLimit ??
            userConfig.generalLimits?.attributeCountLimit ??
            getNumberFromEnv() ??
            getNumberFromEnv() ??
            DEFAULT_ATTRIBUTE_COUNT_LIMIT$1;
    /**
     * Reassign span attribute value length limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeValueLengthLimit =
        userConfig.spanLimits?.attributeValueLengthLimit ??
            userConfig.generalLimits?.attributeValueLengthLimit ??
            getNumberFromEnv() ??
            getNumberFromEnv() ??
            DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT$1;
    return Object.assign({}, userConfig, { spanLimits });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementation of the {@link SpanProcessor} that batches spans exported by
 * the SDK then pushes them to the exporter pipeline.
 */
class BatchSpanProcessorBase {
    _exporter;
    _maxExportBatchSize;
    _maxQueueSize;
    _scheduledDelayMillis;
    _exportTimeoutMillis;
    _isExporting = false;
    _finishedSpans = [];
    _timer;
    _shutdownOnce;
    _droppedSpansCount = 0;
    constructor(_exporter, config) {
        this._exporter = _exporter;
        this._maxExportBatchSize =
            typeof config?.maxExportBatchSize === 'number'
                ? config.maxExportBatchSize
                : (512);
        this._maxQueueSize =
            typeof config?.maxQueueSize === 'number'
                ? config.maxQueueSize
                : (2048);
        this._scheduledDelayMillis =
            typeof config?.scheduledDelayMillis === 'number'
                ? config.scheduledDelayMillis
                : (5000);
        this._exportTimeoutMillis =
            typeof config?.exportTimeoutMillis === 'number'
                ? config.exportTimeoutMillis
                : (30000);
        this._shutdownOnce = new BindOnceFuture$1(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
            diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
            this._maxExportBatchSize = this._maxQueueSize;
        }
    }
    forceFlush() {
        if (this._shutdownOnce.isCalled) {
            return this._shutdownOnce.promise;
        }
        return this._flushAll();
    }
    // does nothing.
    onStart(_span, _parentContext) { }
    onEnd(span) {
        if (this._shutdownOnce.isCalled) {
            return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
            return;
        }
        this._addToBuffer(span);
    }
    shutdown() {
        return this._shutdownOnce.call();
    }
    _shutdown() {
        return Promise.resolve()
            .then(() => {
            return this.onShutdown();
        })
            .then(() => {
            return this._flushAll();
        })
            .then(() => {
            return this._exporter.shutdown();
        });
    }
    /** Add a span in the buffer. */
    _addToBuffer(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
            // limit reached, drop span
            if (this._droppedSpansCount === 0) {
                diag.debug('maxQueueSize reached, dropping spans');
            }
            this._droppedSpansCount++;
            return;
        }
        if (this._droppedSpansCount > 0) {
            // some spans were dropped, log once with count of spans dropped
            diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
            this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
    }
    /**
     * Send all spans to the exporter respecting the batch size limit
     * This function is used only on forceFlush or shutdown,
     * for all other cases _flush should be used
     * */
    _flushAll() {
        return new Promise((resolve, reject) => {
            const promises = [];
            // calculate number of batches
            const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
            for (let i = 0, j = count; i < j; i++) {
                promises.push(this._flushOneBatch());
            }
            Promise.all(promises)
                .then(() => {
                resolve();
            })
                .catch(reject);
        });
    }
    _flushOneBatch() {
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                // don't wait anymore for export, this way the next batch can start
                reject(new Error('Timeout'));
            }, this._exportTimeoutMillis);
            // prevent downstream exporter calls from generating spans
            context.with(suppressTracing(context.active()), () => {
                // Reset the finished spans buffer here because the next invocations of the _flush method
                // could pass the same finished spans to the exporter if the buffer is cleared
                // outside the execution of this callback.
                let spans;
                if (this._finishedSpans.length <= this._maxExportBatchSize) {
                    spans = this._finishedSpans;
                    this._finishedSpans = [];
                }
                else {
                    spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
                }
                const doExport = () => this._exporter.export(spans, result => {
                    clearTimeout(timer);
                    if (result.code === ExportResultCode$1.SUCCESS) {
                        resolve();
                    }
                    else {
                        reject(result.error ??
                            new Error('BatchSpanProcessor: span export failed'));
                    }
                });
                let pendingResources = null;
                for (let i = 0, len = spans.length; i < len; i++) {
                    const span = spans[i];
                    if (span.resource.asyncAttributesPending &&
                        span.resource.waitForAsyncAttributes) {
                        pendingResources ??= [];
                        pendingResources.push(span.resource.waitForAsyncAttributes());
                    }
                }
                // Avoid scheduling a promise to make the behavior more predictable and easier to test
                if (pendingResources === null) {
                    doExport();
                }
                else {
                    Promise.all(pendingResources).then(doExport, err => {
                        globalErrorHandler(err);
                        reject(err);
                    });
                }
            });
        });
    }
    _maybeStartTimer() {
        if (this._isExporting)
            return;
        const flush = () => {
            this._isExporting = true;
            this._flushOneBatch()
                .finally(() => {
                this._isExporting = false;
                if (this._finishedSpans.length > 0) {
                    this._clearTimer();
                    this._maybeStartTimer();
                }
            })
                .catch(e => {
                this._isExporting = false;
                globalErrorHandler(e);
            });
        };
        // we only wait if the queue doesn't have enough elements yet
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
            return flush();
        }
        if (this._timer !== undefined)
            return;
        this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);
        unrefTimer(this._timer);
    }
    _clearTimer() {
        if (this._timer !== undefined) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BatchSpanProcessor extends BatchSpanProcessorBase {
    _visibilityChangeListener;
    _pageHideListener;
    constructor(_exporter, config) {
        super(_exporter, config);
        this.onInit(config);
    }
    onInit(config) {
        if (config?.disableAutoFlushOnDocumentHide !== true &&
            typeof document !== 'undefined') {
            this._visibilityChangeListener = () => {
                if (document.visibilityState === 'hidden') {
                    this.forceFlush().catch(error => {
                        globalErrorHandler(error);
                    });
                }
            };
            this._pageHideListener = () => {
                this.forceFlush().catch(error => {
                    globalErrorHandler(error);
                });
            };
            document.addEventListener('visibilitychange', this._visibilityChangeListener);
            // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769
            document.addEventListener('pagehide', this._pageHideListener);
        }
    }
    onShutdown() {
        if (typeof document !== 'undefined') {
            if (this._visibilityChangeListener) {
                document.removeEventListener('visibilitychange', this._visibilityChangeListener);
            }
            if (this._pageHideListener) {
                document.removeEventListener('pagehide', this._pageHideListener);
            }
        }
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SPAN_ID_BYTES = 8;
const TRACE_ID_BYTES = 16;
class RandomIdGenerator {
    /**
     * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
     * characters corresponding to 128 bits.
     */
    generateTraceId = getIdGenerator(TRACE_ID_BYTES);
    /**
     * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
     * characters corresponding to 64 bits.
     */
    generateSpanId = getIdGenerator(SPAN_ID_BYTES);
}
const SHARED_CHAR_CODES_ARRAY = Array(32);
function getIdGenerator(bytes) {
    return function generateId() {
        for (let i = 0; i < bytes * 2; i++) {
            SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
            // valid hex characters in the range 48-57 and 97-102
            if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
                SHARED_CHAR_CODES_ARRAY[i] += 39;
            }
        }
        return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class represents a basic tracer.
 */
class Tracer {
    _sampler;
    _generalLimits;
    _spanLimits;
    _idGenerator;
    instrumentationScope;
    _resource;
    _spanProcessor;
    /**
     * Constructs a new Tracer instance.
     */
    constructor(instrumentationScope, config, resource, spanProcessor) {
        const localConfig = mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new RandomIdGenerator();
        this._resource = resource;
        this._spanProcessor = spanProcessor;
        this.instrumentationScope = instrumentationScope;
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    startSpan(name, options = {}, context$1 = context.active()) {
        // remove span from context in case a root span is requested via options
        if (options.root) {
            context$1 = trace.deleteSpan(context$1);
        }
        const parentSpan = trace.getSpan(context$1);
        if (isTracingSuppressed(context$1)) {
            diag.debug('Instrumentation suppressed, returning Noop Span');
            const nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
            return nonRecordingSpan;
        }
        const parentSpanContext = parentSpan?.spanContext();
        const spanId = this._idGenerator.generateSpanId();
        let validParentSpanContext;
        let traceId;
        let traceState;
        if (!parentSpanContext ||
            !trace.isSpanContextValid(parentSpanContext)) {
            // New root span.
            traceId = this._idGenerator.generateTraceId();
        }
        else {
            // New child span.
            traceId = parentSpanContext.traceId;
            traceState = parentSpanContext.traceState;
            validParentSpanContext = parentSpanContext;
        }
        const spanKind = options.kind ?? SpanKind.INTERNAL;
        const links = (options.links ?? []).map(link => {
            return {
                context: link.context,
                attributes: sanitizeAttributes(link.attributes),
            };
        });
        const attributes = sanitizeAttributes(options.attributes);
        // make sampling decision
        const samplingResult = this._sampler.shouldSample(context$1, traceId, name, spanKind, attributes, links);
        traceState = samplingResult.traceState ?? traceState;
        const traceFlags = samplingResult.decision === SamplingDecision$1.RECORD_AND_SAMPLED
            ? TraceFlags.SAMPLED
            : TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === SamplingDecision$1.NOT_RECORD) {
            diag.debug('Recording is off, propagating context in a non-recording span');
            const nonRecordingSpan = trace.wrapSpanContext(spanContext);
            return nonRecordingSpan;
        }
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        const initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        const span = new SpanImpl({
            resource: this._resource,
            scope: this.instrumentationScope,
            context: context$1,
            spanContext,
            name,
            kind: spanKind,
            links,
            parentSpanContext: validParentSpanContext,
            attributes: initAttributes,
            startTime: options.startTime,
            spanProcessor: this._spanProcessor,
            spanLimits: this._spanLimits,
        });
        return span;
    }
    startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        const parentContext = ctx ?? context.active();
        const span = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = trace.setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, undefined, span);
    }
    /** Returns the active {@link GeneralLimits}. */
    getGeneralLimits() {
        return this._generalLimits;
    }
    /** Returns the active {@link SpanLimits}. */
    getSpanLimits() {
        return this._spanLimits;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementation of the {@link SpanProcessor} that simply forwards all
 * received events to a list of {@link SpanProcessor}s.
 */
class MultiSpanProcessor {
    _spanProcessors;
    constructor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
    }
    forceFlush() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
            promises.push(spanProcessor.forceFlush());
        }
        return new Promise(resolve => {
            Promise.all(promises)
                .then(() => {
                resolve();
            })
                .catch(error => {
                globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));
                resolve();
            });
        });
    }
    onStart(span, context) {
        for (const spanProcessor of this._spanProcessors) {
            spanProcessor.onStart(span, context);
        }
    }
    onEnd(span) {
        for (const spanProcessor of this._spanProcessors) {
            spanProcessor.onEnd(span);
        }
    }
    shutdown() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
            promises.push(spanProcessor.shutdown());
        }
        return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
                resolve();
            }, reject);
        });
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ForceFlushState;
(function (ForceFlushState) {
    ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
    ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
    ForceFlushState[ForceFlushState["error"] = 2] = "error";
    ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
/**
 * This class represents a basic tracer provider which platform libraries can extend
 */
class BasicTracerProvider {
    _config;
    _tracers = new Map();
    _resource;
    _activeSpanProcessor;
    constructor(config = {}) {
        const mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
        this._resource = mergedConfig.resource ?? defaultResource();
        this._config = Object.assign({}, mergedConfig, {
            resource: this._resource,
        });
        const spanProcessors = [];
        if (config.spanProcessors?.length) {
            spanProcessors.push(...config.spanProcessors);
        }
        this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);
    }
    getTracer(name, version, options) {
        const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;
        if (!this._tracers.has(key)) {
            this._tracers.set(key, new Tracer({ name, version, schemaUrl: options?.schemaUrl }, this._config, this._resource, this._activeSpanProcessor));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
    }
    forceFlush() {
        const timeout = this._config.forceFlushTimeoutMillis;
        const promises = this._activeSpanProcessor['_spanProcessors'].map((spanProcessor) => {
            return new Promise(resolve => {
                let state;
                const timeoutInterval = setTimeout(() => {
                    resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
                    state = ForceFlushState.timeout;
                }, timeout);
                spanProcessor
                    .forceFlush()
                    .then(() => {
                    clearTimeout(timeoutInterval);
                    if (state !== ForceFlushState.timeout) {
                        state = ForceFlushState.resolved;
                        resolve(state);
                    }
                })
                    .catch(error => {
                    clearTimeout(timeoutInterval);
                    state = ForceFlushState.error;
                    resolve(error);
                });
            });
        });
        return new Promise((resolve, reject) => {
            Promise.all(promises)
                .then(results => {
                const errors = results.filter(result => result !== ForceFlushState.resolved);
                if (errors.length > 0) {
                    reject(errors);
                }
                else {
                    resolve();
                }
            })
                .catch(error => reject([error]));
        });
    }
    shutdown() {
        return this._activeSpanProcessor.shutdown();
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Stack Context Manager for managing the state in web
 * it doesn't fully support the async calls though
 */
class StackContextManager {
    /**
     * whether the context manager is enabled or not
     */
    _enabled = false;
    /**
     * Keeps the reference to current context
     */
    _currentContext = ROOT_CONTEXT;
    /**
     *
     * @param context
     * @param target Function to be executed within the context
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    _bindFunction(context = ROOT_CONTEXT, target) {
        const manager = this;
        const contextWrapper = function (...args) {
            return manager.with(context, () => target.apply(this, args));
        };
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: target.length,
        });
        return contextWrapper;
    }
    /**
     * Returns the active context
     */
    active() {
        return this._currentContext;
    }
    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */
    bind(context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
            context = this.active();
        }
        if (typeof target === 'function') {
            return this._bindFunction(context, target);
        }
        return target;
    }
    /**
     * Disable the context manager (clears the current context)
     */
    disable() {
        this._currentContext = ROOT_CONTEXT;
        this._enabled = false;
        return this;
    }
    /**
     * Enables the context manager and creates a default(root) context
     */
    enable() {
        if (this._enabled) {
            return this;
        }
        this._enabled = true;
        this._currentContext = ROOT_CONTEXT;
        return this;
    }
    /**
     * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.
     * The context will be set as active
     * @param context
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    with(context, fn, thisArg, ...args) {
        const previousContext = this._currentContext;
        this._currentContext = context || ROOT_CONTEXT;
        try {
            return fn.call(thisArg, ...args);
        }
        finally {
            this._currentContext = previousContext;
        }
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setupContextManager(contextManager) {
    // null means 'do not register'
    if (contextManager === null) {
        return;
    }
    // undefined means 'register default'
    if (contextManager === undefined) {
        const defaultContextManager = new StackContextManager();
        defaultContextManager.enable();
        context.setGlobalContextManager(defaultContextManager);
        return;
    }
    contextManager.enable();
    context.setGlobalContextManager(contextManager);
}
function setupPropagator(propagator) {
    // null means 'do not register'
    if (propagator === null) {
        return;
    }
    // undefined means 'register default'
    if (propagator === undefined) {
        propagation.setGlobalPropagator(new CompositePropagator({
            propagators: [
                new W3CTraceContextPropagator(),
                new W3CBaggagePropagator(),
            ],
        }));
        return;
    }
    propagation.setGlobalPropagator(propagator);
}
/**
 * This class represents a web tracer with {@link StackContextManager}
 */
class WebTracerProvider extends BasicTracerProvider {
    /**
     * Constructs a new Tracer instance.
     * @param config Web Tracer config
     */
    constructor(config = {}) {
        super(config);
    }
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */
    register(config = {}) {
        trace.setGlobalTracerProvider(this);
        setupPropagator(config.propagator);
        setupContextManager(config.contextManager);
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PerformanceTimingNames;
(function (PerformanceTimingNames) {
    PerformanceTimingNames["CONNECT_END"] = "connectEnd";
    PerformanceTimingNames["CONNECT_START"] = "connectStart";
    PerformanceTimingNames["DECODED_BODY_SIZE"] = "decodedBodySize";
    PerformanceTimingNames["DOM_COMPLETE"] = "domComplete";
    PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_END"] = "domContentLoadedEventEnd";
    PerformanceTimingNames["DOM_CONTENT_LOADED_EVENT_START"] = "domContentLoadedEventStart";
    PerformanceTimingNames["DOM_INTERACTIVE"] = "domInteractive";
    PerformanceTimingNames["DOMAIN_LOOKUP_END"] = "domainLookupEnd";
    PerformanceTimingNames["DOMAIN_LOOKUP_START"] = "domainLookupStart";
    PerformanceTimingNames["ENCODED_BODY_SIZE"] = "encodedBodySize";
    PerformanceTimingNames["FETCH_START"] = "fetchStart";
    PerformanceTimingNames["LOAD_EVENT_END"] = "loadEventEnd";
    PerformanceTimingNames["LOAD_EVENT_START"] = "loadEventStart";
    PerformanceTimingNames["NAVIGATION_START"] = "navigationStart";
    PerformanceTimingNames["REDIRECT_END"] = "redirectEnd";
    PerformanceTimingNames["REDIRECT_START"] = "redirectStart";
    PerformanceTimingNames["REQUEST_START"] = "requestStart";
    PerformanceTimingNames["RESPONSE_END"] = "responseEnd";
    PerformanceTimingNames["RESPONSE_START"] = "responseStart";
    PerformanceTimingNames["SECURE_CONNECTION_START"] = "secureConnectionStart";
    PerformanceTimingNames["START_TIME"] = "startTime";
    PerformanceTimingNames["UNLOAD_EVENT_END"] = "unloadEventEnd";
    PerformanceTimingNames["UNLOAD_EVENT_START"] = "unloadEventStart";
})(PerformanceTimingNames || (PerformanceTimingNames = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file contains a copy of unstable semantic convention definitions
 * used by this package.
 * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv
 */
/**
 * Deprecated, use `http.response.header.<key>` instead.
 *
 * @example 3495
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `http.response.header.<key>`.
 */
const ATTR_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length';
/**
 * Deprecated, use `http.response.body.size` instead.
 *
 * @example 5493
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replace by `http.response.body.size`.
 */
const ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = 'http.response_content_length_uncompressed';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Used to normalize relative URLs
let urlNormalizingAnchor;
function getUrlNormalizingAnchor() {
    if (!urlNormalizingAnchor) {
        urlNormalizingAnchor = document.createElement('a');
    }
    return urlNormalizingAnchor;
}
/**
 * Helper function to be able to use enum as typed key in type and in interface when using forEach
 * @param obj
 * @param key
 */
function hasKey(obj, key) {
    return key in obj;
}
/**
 * Helper function for starting an event on span based on {@link PerformanceEntries}
 * @param span
 * @param performanceName name of performance entry for time start
 * @param entries
 * @param ignoreZeros
 */
function addSpanNetworkEvent(span, performanceName, entries, ignoreZeros = true) {
    if (hasKey(entries, performanceName) &&
        typeof entries[performanceName] === 'number' &&
        !(ignoreZeros && entries[performanceName] === 0)) {
        return span.addEvent(performanceName, entries[performanceName]);
    }
    return undefined;
}
/**
 * Helper function for adding network events and content length attributes.
 */
function addSpanNetworkEvents(span, resource, ignoreNetworkEvents = false, ignoreZeros, skipOldSemconvContentLengthAttrs) {
    if (ignoreZeros === undefined) {
        ignoreZeros = resource[PerformanceTimingNames.START_TIME] !== 0;
    }
    if (!ignoreNetworkEvents) {
        addSpanNetworkEvent(span, PerformanceTimingNames.FETCH_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.DOMAIN_LOOKUP_END, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.SECURE_CONNECTION_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.CONNECT_END, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.REQUEST_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_START, resource, ignoreZeros);
        addSpanNetworkEvent(span, PerformanceTimingNames.RESPONSE_END, resource, ignoreZeros);
    }
    if (!skipOldSemconvContentLengthAttrs) {
        // This block adds content-length-related span attributes using the
        // *old* HTTP semconv (v1.7.0).
        const encodedLength = resource[PerformanceTimingNames.ENCODED_BODY_SIZE];
        if (encodedLength !== undefined) {
            span.setAttribute(ATTR_HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);
        }
        const decodedLength = resource[PerformanceTimingNames.DECODED_BODY_SIZE];
        // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)
        if (decodedLength !== undefined && encodedLength !== decodedLength) {
            span.setAttribute(ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, decodedLength);
        }
    }
}
/**
 * sort resources by startTime
 * @param filteredResources
 */
function sortResources(filteredResources) {
    return filteredResources.slice().sort((a, b) => {
        const valueA = a[PerformanceTimingNames.FETCH_START];
        const valueB = b[PerformanceTimingNames.FETCH_START];
        if (valueA > valueB) {
            return 1;
        }
        else if (valueA < valueB) {
            return -1;
        }
        return 0;
    });
}
/** Returns the origin if present (if in browser context). */
function getOrigin() {
    return typeof location !== 'undefined' ? location.origin : undefined;
}
/**
 * Get closest performance resource ignoring the resources that have been
 * already used.
 * @param spanUrl
 * @param startTimeHR
 * @param endTimeHR
 * @param resources
 * @param ignoredResources
 * @param initiatorType
 */
function getResource(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources = new WeakSet(), initiatorType) {
    // de-relativize the URL before usage (does no harm to absolute URLs)
    const parsedSpanUrl = parseUrl(spanUrl);
    spanUrl = parsedSpanUrl.toString();
    const filteredResources = filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType);
    if (filteredResources.length === 0) {
        return {
            mainRequest: undefined,
        };
    }
    if (filteredResources.length === 1) {
        return {
            mainRequest: filteredResources[0],
        };
    }
    const sorted = sortResources(filteredResources);
    if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {
        let corsPreFlightRequest = sorted[0];
        let mainRequest = findMainRequest(sorted, corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END], endTimeHR);
        const responseEnd = corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END];
        const fetchStart = mainRequest[PerformanceTimingNames.FETCH_START];
        // no corsPreFlightRequest
        if (fetchStart < responseEnd) {
            mainRequest = corsPreFlightRequest;
            corsPreFlightRequest = undefined;
        }
        return {
            corsPreFlightRequest,
            mainRequest,
        };
    }
    else {
        return {
            mainRequest: filteredResources[0],
        };
    }
}
/**
 * Will find the main request skipping the cors pre flight requests
 * @param resources
 * @param corsPreFlightRequestEndTime
 * @param spanEndTimeHR
 */
function findMainRequest(resources, corsPreFlightRequestEndTime, spanEndTimeHR) {
    const spanEndTime = hrTimeToNanoseconds$1(spanEndTimeHR);
    const minTime = hrTimeToNanoseconds$1(timeInputToHrTime(corsPreFlightRequestEndTime));
    let mainRequest = resources[1];
    let bestGap;
    const length = resources.length;
    for (let i = 1; i < length; i++) {
        const resource = resources[i];
        const resourceStartTime = hrTimeToNanoseconds$1(timeInputToHrTime(resource[PerformanceTimingNames.FETCH_START]));
        const resourceEndTime = hrTimeToNanoseconds$1(timeInputToHrTime(resource[PerformanceTimingNames.RESPONSE_END]));
        const currentGap = spanEndTime - resourceEndTime;
        if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {
            bestGap = currentGap;
            mainRequest = resource;
        }
    }
    return mainRequest;
}
/**
 * Filter all resources that has started and finished according to span start time and end time.
 *     It will return the closest resource to a start time
 * @param spanUrl
 * @param startTimeHR
 * @param endTimeHR
 * @param resources
 * @param ignoredResources
 */
function filterResourcesForSpan(spanUrl, startTimeHR, endTimeHR, resources, ignoredResources, initiatorType) {
    const startTime = hrTimeToNanoseconds$1(startTimeHR);
    const endTime = hrTimeToNanoseconds$1(endTimeHR);
    let filteredResources = resources.filter(resource => {
        const resourceStartTime = hrTimeToNanoseconds$1(timeInputToHrTime(resource[PerformanceTimingNames.FETCH_START]));
        const resourceEndTime = hrTimeToNanoseconds$1(timeInputToHrTime(resource[PerformanceTimingNames.RESPONSE_END]));
        return (resource.initiatorType.toLowerCase() ===
            (initiatorType || 'xmlhttprequest') &&
            resource.name === spanUrl &&
            resourceStartTime >= startTime &&
            resourceEndTime <= endTime);
    });
    if (filteredResources.length > 0) {
        filteredResources = filteredResources.filter(resource => {
            return !ignoredResources.has(resource);
        });
    }
    return filteredResources;
}
/**
 * Parses url using URL constructor or fallback to anchor element.
 * @param url
 */
function parseUrl(url) {
    if (typeof URL === 'function') {
        return new URL(url, typeof document !== 'undefined'
            ? document.baseURI
            : typeof location !== 'undefined' // Some JS runtimes (e.g. Deno) don't define this
                ? location.href
                : undefined);
    }
    const element = getUrlNormalizingAnchor();
    element.href = url;
    return element;
}
/**
 * Get element XPath
 * @param target - target element
 * @param optimised - when id attribute of element is present the xpath can be
 * simplified to contain id
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function getElementXPath(target, optimised) {
    if (target.nodeType === Node.DOCUMENT_NODE) {
        return '/';
    }
    const targetValue = getNodeValue(target, optimised);
    if (optimised && targetValue.indexOf('@id') > 0) {
        return targetValue;
    }
    let xpath = '';
    if (target.parentNode) {
        xpath += getElementXPath(target.parentNode, false);
    }
    xpath += targetValue;
    return xpath;
}
/**
 * get node index within the siblings
 * @param target
 */
function getNodeIndex(target) {
    if (!target.parentNode) {
        return 0;
    }
    const allowedTypes = [target.nodeType];
    if (target.nodeType === Node.CDATA_SECTION_NODE) {
        allowedTypes.push(Node.TEXT_NODE);
    }
    let elements = Array.from(target.parentNode.childNodes);
    elements = elements.filter((element) => {
        const localName = element.localName;
        return (allowedTypes.indexOf(element.nodeType) >= 0 &&
            localName === target.localName);
    });
    if (elements.length >= 1) {
        return elements.indexOf(target) + 1; // xpath starts from 1
    }
    // if there are no other similar child xpath doesn't need index
    return 0;
}
/**
 * get node value for xpath
 * @param target
 * @param optimised
 */
function getNodeValue(target, optimised) {
    const nodeType = target.nodeType;
    const index = getNodeIndex(target);
    let nodeValue = '';
    if (nodeType === Node.ELEMENT_NODE) {
        const id = target.getAttribute('id');
        if (optimised && id) {
            return `//*[@id="${id}"]`;
        }
        nodeValue = target.localName;
    }
    else if (nodeType === Node.TEXT_NODE ||
        nodeType === Node.CDATA_SECTION_NODE) {
        nodeValue = 'text()';
    }
    else if (nodeType === Node.COMMENT_NODE) {
        nodeValue = 'comment()';
    }
    else {
        return '';
    }
    // if index is 1 it can be omitted in xpath
    if (nodeValue && index > 1) {
        return `/${nodeValue}[${index}]`;
    }
    return `/${nodeValue}`;
}
/**
 * Checks if trace headers should be propagated
 * @param spanUrl
 * @private
 */
function shouldPropagateTraceHeaders(spanUrl, propagateTraceHeaderCorsUrls) {
    let propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];
    if (typeof propagateTraceHeaderUrls === 'string' ||
        propagateTraceHeaderUrls instanceof RegExp) {
        propagateTraceHeaderUrls = [propagateTraceHeaderUrls];
    }
    const parsedSpanUrl = parseUrl(spanUrl);
    if (parsedSpanUrl.origin === getOrigin()) {
        return true;
    }
    else {
        return propagateTraceHeaderUrls.some(propagateTraceHeaderUrl => urlMatches$2(spanUrl, propagateTraceHeaderUrl));
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * check if an object has `addEventListener` and `removeEventListener` functions.
 * Generally only called with a `TargetWithEvents` but may be called with an `unknown` value.
 * @param obj - The object to check.
 */
function isListenerObject(obj) {
    return (typeof obj === 'object' &&
        obj !== null &&
        'addEventListener' in obj &&
        typeof obj.addEventListener === 'function' &&
        'removeEventListener' in obj &&
        typeof obj.removeEventListener === 'function');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="zone.js" />
/* Key name to be used to save a context reference in Zone */
const ZONE_CONTEXT_KEY$1 = 'OT_ZONE_CONTEXT';
/**
 * ZoneContextManager
 * This module provides an easy functionality for tracing action between asynchronous operations in web.
 * It was not possible with standard [StackContextManager]{@link https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-sdk-trace-web/src/StackContextManager.ts}.
 * It heavily depends on [zone.js]{@link https://www.npmjs.com/package/zone.js}.
 * It stores the information about context in zone. Each Context will have always new Zone;
 * It also supports binding a certain Span to a target that has "addEventListener" and "removeEventListener".
 * When this happens a new zone is being created and the provided Span is being assigned to this zone.
 */
class ZoneContextManager {
    /**
     * whether the context manager is enabled or not
     */
    _enabled = false;
    /**
     * Helps to create a unique name for the zones - part of zone name
     */
    _zoneCounter = 0;
    /**
     * Returns the active context from certain zone name
     * @param activeZone
     */
    _activeContextFromZone(activeZone) {
        return (activeZone && activeZone.get(ZONE_CONTEXT_KEY$1)) || ROOT_CONTEXT;
    }
    /**
     * @param context A context (span) to be executed within target function
     * @param target Function to be executed within the context
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    _bindFunction(context, target) {
        const manager = this;
        const contextWrapper = function (...args) {
            return manager.with(context, () => target.apply(this, args));
        };
        Object.defineProperty(contextWrapper, 'length', {
            enumerable: false,
            configurable: true,
            writable: false,
            value: target.length,
        });
        return contextWrapper;
    }
    /**
     * @param context A context (span) to be bind to target
     * @param obj target object on which the listeners will be patched
     */
    _bindListener(context, obj) {
        const target = obj;
        if (target.__ot_listeners !== undefined) {
            return obj;
        }
        target.__ot_listeners = {};
        if (typeof target.addEventListener === 'function') {
            target.addEventListener = this._patchAddEventListener(target, target.addEventListener, context);
        }
        if (typeof target.removeEventListener === 'function') {
            target.removeEventListener = this._patchRemoveEventListener(target, target.removeEventListener);
        }
        return obj;
    }
    /**
     * Creates a new unique zone name
     */
    _createZoneName() {
        this._zoneCounter++;
        const random = Math.random();
        return `${this._zoneCounter}-${random}`;
    }
    /**
     * Creates a new zone
     * @param zoneName zone name
     * @param context A context (span) to be bind with Zone
     */
    _createZone(zoneName, context) {
        return Zone.current.fork({
            name: zoneName,
            properties: {
                [ZONE_CONTEXT_KEY$1]: context,
            },
        });
    }
    /**
     * Returns the active zone
     */
    _getActiveZone() {
        return Zone.current;
    }
    /**
     * Patches addEventListener method
     * @param target any target that has "addEventListener" method
     * @param original reference to the patched method
     * @param [context] context to be bind to the listener
     */
    _patchAddEventListener(target, original, context) {
        const contextManager = this;
        return function (event, listener, opts) {
            if (target.__ot_listeners === undefined) {
                target.__ot_listeners = {};
            }
            let listeners = target.__ot_listeners[event];
            if (listeners === undefined) {
                listeners = new WeakMap();
                target.__ot_listeners[event] = listeners;
            }
            const patchedListener = contextManager.bind(context, listener);
            // store a weak reference of the user listener to ours
            listeners.set(listener, patchedListener);
            return original.call(this, event, patchedListener, opts);
        };
    }
    /**
     * Patches removeEventListener method
     * @param target any target that has "removeEventListener" method
     * @param original reference to the patched method
     */
    _patchRemoveEventListener(target, original) {
        return function (event, listener) {
            if (target.__ot_listeners === undefined ||
                target.__ot_listeners[event] === undefined) {
                return original.call(this, event, listener);
            }
            const events = target.__ot_listeners[event];
            const patchedListener = events.get(listener);
            events.delete(listener);
            return original.call(this, event, patchedListener || listener);
        };
    }
    /**
     * Returns the active context
     */
    active() {
        if (!this._enabled) {
            return ROOT_CONTEXT;
        }
        const activeZone = this._getActiveZone();
        const active = this._activeContextFromZone(activeZone);
        if (active) {
            return active;
        }
        return ROOT_CONTEXT;
    }
    /**
     * Binds a the certain context or the active one to the target function and then returns the target
     * @param context A context (span) to be bind to target
     * @param target a function or event emitter. When target or one of its callbacks is called,
     *  the provided context will be used as the active context for the duration of the call.
     */
    bind(context, target) {
        // if no specific context to propagate is given, we use the current one
        if (context === undefined) {
            context = this.active();
        }
        if (typeof target === 'function') {
            return this._bindFunction(context, target);
        }
        else if (isListenerObject(target)) {
            this._bindListener(context, target);
        }
        return target;
    }
    /**
     * Disable the context manager (clears all the contexts)
     */
    disable() {
        this._enabled = false;
        return this;
    }
    /**
     * Enables the context manager and creates a default(root) context
     */
    enable() {
        this._enabled = true;
        return this;
    }
    /**
     * Calls the callback function [fn] with the provided [context].
     *     If [context] is undefined then it will use the active context.
     *     The context will be set as active
     * @param context A context (span) to be called with provided callback
     * @param fn Callback function
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    with(context, fn, thisArg, ...args) {
        const zoneName = this._createZoneName();
        const newZone = this._createZone(zoneName, context);
        return newZone.run(fn, thisArg, args);
    }
}

var zone = {};

var hasRequiredZone;

function requireZone () {
	if (hasRequiredZone) return zone;
	hasRequiredZone = 1;
	/**
	 * @license Angular v<unknown>
	 * (c) 2010-2024 Google LLC. https://angular.io/
	 * License: MIT
	 */
	const global = globalThis;
	// __Zone_symbol_prefix global can be used to override the default zone
	// symbol prefix with a custom one if needed.
	function __symbol__(name) {
	    const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';
	    return symbolPrefix + name;
	}
	function initZone() {
	    const performance = global['performance'];
	    function mark(name) {
	        performance && performance['mark'] && performance['mark'](name);
	    }
	    function performanceMeasure(name, label) {
	        performance && performance['measure'] && performance['measure'](name, label);
	    }
	    mark('Zone');
	    class ZoneImpl {
	        // tslint:disable-next-line:require-internal-with-underscore
	        static { this.__symbol__ = __symbol__; }
	        static assertZonePatched() {
	            if (global['Promise'] !== patches['ZoneAwarePromise']) {
	                throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' +
	                    'has been overwritten.\n' +
	                    'Most likely cause is that a Promise polyfill has been loaded ' +
	                    'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' +
	                    'If you must load one, do so before loading zone.js.)');
	            }
	        }
	        static get root() {
	            let zone = ZoneImpl.current;
	            while (zone.parent) {
	                zone = zone.parent;
	            }
	            return zone;
	        }
	        static get current() {
	            return _currentZoneFrame.zone;
	        }
	        static get currentTask() {
	            return _currentTask;
	        }
	        // tslint:disable-next-line:require-internal-with-underscore
	        static __load_patch(name, fn, ignoreDuplicate = false) {
	            if (patches.hasOwnProperty(name)) {
	                // `checkDuplicate` option is defined from global variable
	                // so it works for all modules.
	                // `ignoreDuplicate` can work for the specified module
	                const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
	                if (!ignoreDuplicate && checkDuplicate) {
	                    throw Error('Already loaded patch: ' + name);
	                }
	            }
	            else if (!global['__Zone_disable_' + name]) {
	                const perfName = 'Zone:' + name;
	                mark(perfName);
	                patches[name] = fn(global, ZoneImpl, _api);
	                performanceMeasure(perfName, perfName);
	            }
	        }
	        get parent() {
	            return this._parent;
	        }
	        get name() {
	            return this._name;
	        }
	        constructor(parent, zoneSpec) {
	            this._parent = parent;
	            this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
	            this._properties = (zoneSpec && zoneSpec.properties) || {};
	            this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
	        }
	        get(key) {
	            const zone = this.getZoneWith(key);
	            if (zone)
	                return zone._properties[key];
	        }
	        getZoneWith(key) {
	            let current = this;
	            while (current) {
	                if (current._properties.hasOwnProperty(key)) {
	                    return current;
	                }
	                current = current._parent;
	            }
	            return null;
	        }
	        fork(zoneSpec) {
	            if (!zoneSpec)
	                throw new Error('ZoneSpec required!');
	            return this._zoneDelegate.fork(this, zoneSpec);
	        }
	        wrap(callback, source) {
	            if (typeof callback !== 'function') {
	                throw new Error('Expecting function got: ' + callback);
	            }
	            const _callback = this._zoneDelegate.intercept(this, callback, source);
	            const zone = this;
	            return function () {
	                return zone.runGuarded(_callback, this, arguments, source);
	            };
	        }
	        run(callback, applyThis, applyArgs, source) {
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	            }
	            finally {
	                _currentZoneFrame = _currentZoneFrame.parent;
	            }
	        }
	        runGuarded(callback, applyThis = null, applyArgs, source) {
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                try {
	                    return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                _currentZoneFrame = _currentZoneFrame.parent;
	            }
	        }
	        runTask(task, applyThis, applyArgs) {
	            if (task.zone != this) {
	                throw new Error('A task can only be run in the zone of creation! (Creation: ' +
	                    (task.zone || NO_ZONE).name +
	                    '; Execution: ' +
	                    this.name +
	                    ')');
	            }
	            const zoneTask = task;
	            // https://github.com/angular/zone.js/issues/778, sometimes eventTask
	            // will run in notScheduled(canceled) state, we should not try to
	            // run such kind of task but just return
	            const { type, data: { isPeriodic = false, isRefreshable = false } = {} } = task;
	            if (task.state === notScheduled && (type === eventTask || type === macroTask)) {
	                return;
	            }
	            const reEntryGuard = task.state != running;
	            reEntryGuard && zoneTask._transitionTo(running, scheduled);
	            const previousTask = _currentTask;
	            _currentTask = zoneTask;
	            _currentZoneFrame = { parent: _currentZoneFrame, zone: this };
	            try {
	                if (type == macroTask && task.data && !isPeriodic && !isRefreshable) {
	                    task.cancelFn = undefined;
	                }
	                try {
	                    return this._zoneDelegate.invokeTask(this, zoneTask, applyThis, applyArgs);
	                }
	                catch (error) {
	                    if (this._zoneDelegate.handleError(this, error)) {
	                        throw error;
	                    }
	                }
	            }
	            finally {
	                // if the task's state is notScheduled or unknown, then it has already been cancelled
	                // we should not reset the state to scheduled
	                const state = task.state;
	                if (state !== notScheduled && state !== unknown) {
	                    if (type == eventTask || isPeriodic || (isRefreshable && state === scheduling)) {
	                        reEntryGuard && zoneTask._transitionTo(scheduled, running, scheduling);
	                    }
	                    else {
	                        const zoneDelegates = zoneTask._zoneDelegates;
	                        this._updateTaskCount(zoneTask, -1);
	                        reEntryGuard && zoneTask._transitionTo(notScheduled, running, notScheduled);
	                        if (isRefreshable) {
	                            zoneTask._zoneDelegates = zoneDelegates;
	                        }
	                    }
	                }
	                _currentZoneFrame = _currentZoneFrame.parent;
	                _currentTask = previousTask;
	            }
	        }
	        scheduleTask(task) {
	            if (task.zone && task.zone !== this) {
	                // check if the task was rescheduled, the newZone
	                // should not be the children of the original zone
	                let newZone = this;
	                while (newZone) {
	                    if (newZone === task.zone) {
	                        throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);
	                    }
	                    newZone = newZone.parent;
	                }
	            }
	            task._transitionTo(scheduling, notScheduled);
	            const zoneDelegates = [];
	            task._zoneDelegates = zoneDelegates;
	            task._zone = this;
	            try {
	                task = this._zoneDelegate.scheduleTask(this, task);
	            }
	            catch (err) {
	                // should set task's state to unknown when scheduleTask throw error
	                // because the err may from reschedule, so the fromState maybe notScheduled
	                task._transitionTo(unknown, scheduling, notScheduled);
	                // TODO: @JiaLiPassion, should we check the result from handleError?
	                this._zoneDelegate.handleError(this, err);
	                throw err;
	            }
	            if (task._zoneDelegates === zoneDelegates) {
	                // we have to check because internally the delegate can reschedule the task.
	                this._updateTaskCount(task, 1);
	            }
	            if (task.state == scheduling) {
	                task._transitionTo(scheduled, scheduling);
	            }
	            return task;
	        }
	        scheduleMicroTask(source, callback, data, customSchedule) {
	            return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
	        }
	        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
	            return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
	        }
	        scheduleEventTask(source, callback, data, customSchedule, customCancel) {
	            return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
	        }
	        cancelTask(task) {
	            if (task.zone != this)
	                throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' +
	                    (task.zone || NO_ZONE).name +
	                    '; Execution: ' +
	                    this.name +
	                    ')');
	            if (task.state !== scheduled && task.state !== running) {
	                return;
	            }
	            task._transitionTo(canceling, scheduled, running);
	            try {
	                this._zoneDelegate.cancelTask(this, task);
	            }
	            catch (err) {
	                // if error occurs when cancelTask, transit the state to unknown
	                task._transitionTo(unknown, canceling);
	                this._zoneDelegate.handleError(this, err);
	                throw err;
	            }
	            this._updateTaskCount(task, -1);
	            task._transitionTo(notScheduled, canceling);
	            task.runCount = -1;
	            return task;
	        }
	        _updateTaskCount(task, count) {
	            const zoneDelegates = task._zoneDelegates;
	            if (count == -1) {
	                task._zoneDelegates = null;
	            }
	            for (let i = 0; i < zoneDelegates.length; i++) {
	                zoneDelegates[i]._updateTaskCount(task.type, count);
	            }
	        }
	    }
	    const DELEGATE_ZS = {
	        name: '',
	        onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
	        onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
	        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
	        onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task),
	    };
	    class _ZoneDelegate {
	        get zone() {
	            return this._zone;
	        }
	        constructor(zone, parentDelegate, zoneSpec) {
	            this._taskCounts = {
	                'microTask': 0,
	                'macroTask': 0,
	                'eventTask': 0,
	            };
	            this._zone = zone;
	            this._parentDelegate = parentDelegate;
	            this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
	            this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
	            this._forkCurrZone =
	                zoneSpec && (zoneSpec.onFork ? this._zone : parentDelegate._forkCurrZone);
	            this._interceptZS =
	                zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
	            this._interceptDlgt =
	                zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
	            this._interceptCurrZone =
	                zoneSpec && (zoneSpec.onIntercept ? this._zone : parentDelegate._interceptCurrZone);
	            this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
	            this._invokeDlgt =
	                zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
	            this._invokeCurrZone =
	                zoneSpec && (zoneSpec.onInvoke ? this._zone : parentDelegate._invokeCurrZone);
	            this._handleErrorZS =
	                zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
	            this._handleErrorDlgt =
	                zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
	            this._handleErrorCurrZone =
	                zoneSpec && (zoneSpec.onHandleError ? this._zone : parentDelegate._handleErrorCurrZone);
	            this._scheduleTaskZS =
	                zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
	            this._scheduleTaskDlgt =
	                zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
	            this._scheduleTaskCurrZone =
	                zoneSpec && (zoneSpec.onScheduleTask ? this._zone : parentDelegate._scheduleTaskCurrZone);
	            this._invokeTaskZS =
	                zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
	            this._invokeTaskDlgt =
	                zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
	            this._invokeTaskCurrZone =
	                zoneSpec && (zoneSpec.onInvokeTask ? this._zone : parentDelegate._invokeTaskCurrZone);
	            this._cancelTaskZS =
	                zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
	            this._cancelTaskDlgt =
	                zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
	            this._cancelTaskCurrZone =
	                zoneSpec && (zoneSpec.onCancelTask ? this._zone : parentDelegate._cancelTaskCurrZone);
	            this._hasTaskZS = null;
	            this._hasTaskDlgt = null;
	            this._hasTaskDlgtOwner = null;
	            this._hasTaskCurrZone = null;
	            const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
	            const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;
	            if (zoneSpecHasTask || parentHasTask) {
	                // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
	                // a case all task related interceptors must go through this ZD. We can't short circuit it.
	                this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
	                this._hasTaskDlgt = parentDelegate;
	                this._hasTaskDlgtOwner = this;
	                this._hasTaskCurrZone = this._zone;
	                if (!zoneSpec.onScheduleTask) {
	                    this._scheduleTaskZS = DELEGATE_ZS;
	                    this._scheduleTaskDlgt = parentDelegate;
	                    this._scheduleTaskCurrZone = this._zone;
	                }
	                if (!zoneSpec.onInvokeTask) {
	                    this._invokeTaskZS = DELEGATE_ZS;
	                    this._invokeTaskDlgt = parentDelegate;
	                    this._invokeTaskCurrZone = this._zone;
	                }
	                if (!zoneSpec.onCancelTask) {
	                    this._cancelTaskZS = DELEGATE_ZS;
	                    this._cancelTaskDlgt = parentDelegate;
	                    this._cancelTaskCurrZone = this._zone;
	                }
	            }
	        }
	        fork(targetZone, zoneSpec) {
	            return this._forkZS
	                ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec)
	                : new ZoneImpl(targetZone, zoneSpec);
	        }
	        intercept(targetZone, callback, source) {
	            return this._interceptZS
	                ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source)
	                : callback;
	        }
	        invoke(targetZone, callback, applyThis, applyArgs, source) {
	            return this._invokeZS
	                ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source)
	                : callback.apply(applyThis, applyArgs);
	        }
	        handleError(targetZone, error) {
	            return this._handleErrorZS
	                ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error)
	                : true;
	        }
	        scheduleTask(targetZone, task) {
	            let returnTask = task;
	            if (this._scheduleTaskZS) {
	                if (this._hasTaskZS) {
	                    returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
	                }
	                returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
	                if (!returnTask)
	                    returnTask = task;
	            }
	            else {
	                if (task.scheduleFn) {
	                    task.scheduleFn(task);
	                }
	                else if (task.type == microTask) {
	                    scheduleMicroTask(task);
	                }
	                else {
	                    throw new Error('Task is missing scheduleFn.');
	                }
	            }
	            return returnTask;
	        }
	        invokeTask(targetZone, task, applyThis, applyArgs) {
	            return this._invokeTaskZS
	                ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs)
	                : task.callback.apply(applyThis, applyArgs);
	        }
	        cancelTask(targetZone, task) {
	            let value;
	            if (this._cancelTaskZS) {
	                value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
	            }
	            else {
	                if (!task.cancelFn) {
	                    throw Error('Task is not cancelable');
	                }
	                value = task.cancelFn(task);
	            }
	            return value;
	        }
	        hasTask(targetZone, isEmpty) {
	            // hasTask should not throw error so other ZoneDelegate
	            // can still trigger hasTask callback
	            try {
	                this._hasTaskZS &&
	                    this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
	            }
	            catch (err) {
	                this.handleError(targetZone, err);
	            }
	        }
	        // tslint:disable-next-line:require-internal-with-underscore
	        _updateTaskCount(type, count) {
	            const counts = this._taskCounts;
	            const prev = counts[type];
	            const next = (counts[type] = prev + count);
	            if (next < 0) {
	                throw new Error('More tasks executed then were scheduled.');
	            }
	            if (prev == 0 || next == 0) {
	                const isEmpty = {
	                    microTask: counts['microTask'] > 0,
	                    macroTask: counts['macroTask'] > 0,
	                    eventTask: counts['eventTask'] > 0,
	                    change: type,
	                };
	                this.hasTask(this._zone, isEmpty);
	            }
	        }
	    }
	    class ZoneTask {
	        constructor(type, source, callback, options, scheduleFn, cancelFn) {
	            // tslint:disable-next-line:require-internal-with-underscore
	            this._zone = null;
	            this.runCount = 0;
	            // tslint:disable-next-line:require-internal-with-underscore
	            this._zoneDelegates = null;
	            // tslint:disable-next-line:require-internal-with-underscore
	            this._state = 'notScheduled';
	            this.type = type;
	            this.source = source;
	            this.data = options;
	            this.scheduleFn = scheduleFn;
	            this.cancelFn = cancelFn;
	            if (!callback) {
	                throw new Error('callback is not defined');
	            }
	            this.callback = callback;
	            const self = this;
	            // TODO: @JiaLiPassion options should have interface
	            if (type === eventTask && options && options.useG) {
	                this.invoke = ZoneTask.invokeTask;
	            }
	            else {
	                this.invoke = function () {
	                    return ZoneTask.invokeTask.call(global, self, this, arguments);
	                };
	            }
	        }
	        static invokeTask(task, target, args) {
	            if (!task) {
	                task = this;
	            }
	            _numberOfNestedTaskFrames++;
	            try {
	                task.runCount++;
	                return task.zone.runTask(task, target, args);
	            }
	            finally {
	                if (_numberOfNestedTaskFrames == 1) {
	                    drainMicroTaskQueue();
	                }
	                _numberOfNestedTaskFrames--;
	            }
	        }
	        get zone() {
	            return this._zone;
	        }
	        get state() {
	            return this._state;
	        }
	        cancelScheduleRequest() {
	            this._transitionTo(notScheduled, scheduling);
	        }
	        // tslint:disable-next-line:require-internal-with-underscore
	        _transitionTo(toState, fromState1, fromState2) {
	            if (this._state === fromState1 || this._state === fromState2) {
	                this._state = toState;
	                if (toState == notScheduled) {
	                    this._zoneDelegates = null;
	                }
	            }
	            else {
	                throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? " or '" + fromState2 + "'" : ''}, was '${this._state}'.`);
	            }
	        }
	        toString() {
	            if (this.data && typeof this.data.handleId !== 'undefined') {
	                return this.data.handleId.toString();
	            }
	            else {
	                return Object.prototype.toString.call(this);
	            }
	        }
	        // add toJSON method to prevent cyclic error when
	        // call JSON.stringify(zoneTask)
	        toJSON() {
	            return {
	                type: this.type,
	                state: this.state,
	                source: this.source,
	                zone: this.zone.name,
	                runCount: this.runCount,
	            };
	        }
	    }
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    ///  MICROTASK QUEUE
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    const symbolSetTimeout = __symbol__('setTimeout');
	    const symbolPromise = __symbol__('Promise');
	    const symbolThen = __symbol__('then');
	    let _microTaskQueue = [];
	    let _isDrainingMicrotaskQueue = false;
	    let nativeMicroTaskQueuePromise;
	    function nativeScheduleMicroTask(func) {
	        if (!nativeMicroTaskQueuePromise) {
	            if (global[symbolPromise]) {
	                nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
	            }
	        }
	        if (nativeMicroTaskQueuePromise) {
	            let nativeThen = nativeMicroTaskQueuePromise[symbolThen];
	            if (!nativeThen) {
	                // native Promise is not patchable, we need to use `then` directly
	                // issue 1078
	                nativeThen = nativeMicroTaskQueuePromise['then'];
	            }
	            nativeThen.call(nativeMicroTaskQueuePromise, func);
	        }
	        else {
	            global[symbolSetTimeout](func, 0);
	        }
	    }
	    function scheduleMicroTask(task) {
	        // if we are not running in any task, and there has not been anything scheduled
	        // we must bootstrap the initial task creation by manually scheduling the drain
	        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
	            // We are not running in Task, so we need to kickstart the microtask queue.
	            nativeScheduleMicroTask(drainMicroTaskQueue);
	        }
	        task && _microTaskQueue.push(task);
	    }
	    function drainMicroTaskQueue() {
	        if (!_isDrainingMicrotaskQueue) {
	            _isDrainingMicrotaskQueue = true;
	            while (_microTaskQueue.length) {
	                const queue = _microTaskQueue;
	                _microTaskQueue = [];
	                for (let i = 0; i < queue.length; i++) {
	                    const task = queue[i];
	                    try {
	                        task.zone.runTask(task, null, null);
	                    }
	                    catch (error) {
	                        _api.onUnhandledError(error);
	                    }
	                }
	            }
	            _api.microtaskDrainDone();
	            _isDrainingMicrotaskQueue = false;
	        }
	    }
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    ///  BOOTSTRAP
	    //////////////////////////////////////////////////////
	    //////////////////////////////////////////////////////
	    const NO_ZONE = { name: 'NO ZONE' };
	    const notScheduled = 'notScheduled', scheduling = 'scheduling', scheduled = 'scheduled', running = 'running', canceling = 'canceling', unknown = 'unknown';
	    const microTask = 'microTask', macroTask = 'macroTask', eventTask = 'eventTask';
	    const patches = {};
	    const _api = {
	        symbol: __symbol__,
	        currentZoneFrame: () => _currentZoneFrame,
	        onUnhandledError: noop,
	        microtaskDrainDone: noop,
	        scheduleMicroTask: scheduleMicroTask,
	        showUncaughtError: () => !ZoneImpl[__symbol__('ignoreConsoleErrorUncaughtError')],
	        patchEventTarget: () => [],
	        patchOnProperties: noop,
	        patchMethod: () => noop,
	        bindArguments: () => [],
	        patchThen: () => noop,
	        patchMacroTask: () => noop,
	        patchEventPrototype: () => noop,
	        isIEOrEdge: () => false,
	        getGlobalObjects: () => undefined,
	        ObjectDefineProperty: () => noop,
	        ObjectGetOwnPropertyDescriptor: () => undefined,
	        ObjectCreate: () => undefined,
	        ArraySlice: () => [],
	        patchClass: () => noop,
	        wrapWithCurrentZone: () => noop,
	        filterProperties: () => [],
	        attachOriginToPatched: () => noop,
	        _redefineProperty: () => noop,
	        patchCallbacks: () => noop,
	        nativeScheduleMicroTask: nativeScheduleMicroTask,
	    };
	    let _currentZoneFrame = { parent: null, zone: new ZoneImpl(null, null) };
	    let _currentTask = null;
	    let _numberOfNestedTaskFrames = 0;
	    function noop() { }
	    performanceMeasure('Zone', 'Zone');
	    return ZoneImpl;
	}

	function loadZone() {
	    // if global['Zone'] already exists (maybe zone.js was already loaded or
	    // some other lib also registered a global object named Zone), we may need
	    // to throw an error, but sometimes user may not want this error.
	    // For example,
	    // we have two web pages, page1 includes zone.js, page2 doesn't.
	    // and the 1st time user load page1 and page2, everything work fine,
	    // but when user load page2 again, error occurs because global['Zone'] already exists.
	    // so we add a flag to let user choose whether to throw this error or not.
	    // By default, if existing Zone is from zone.js, we will not throw the error.
	    const global = globalThis;
	    const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;
	    if (global['Zone'] && (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function')) {
	        throw new Error('Zone already loaded.');
	    }
	    // Initialize global `Zone` constant.
	    global['Zone'] ??= initZone();
	    return global['Zone'];
	}

	/**
	 * Suppress closure compiler errors about unknown 'Zone' variable
	 * @fileoverview
	 * @suppress {undefinedVars,globalThis,missingRequire}
	 */
	// issue #989, to reduce bundle size, use short name
	/** Object.getOwnPropertyDescriptor */
	const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	/** Object.defineProperty */
	const ObjectDefineProperty = Object.defineProperty;
	/** Object.getPrototypeOf */
	const ObjectGetPrototypeOf = Object.getPrototypeOf;
	/** Object.create */
	const ObjectCreate = Object.create;
	/** Array.prototype.slice */
	const ArraySlice = Array.prototype.slice;
	/** addEventListener string const */
	const ADD_EVENT_LISTENER_STR = 'addEventListener';
	/** removeEventListener string const */
	const REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
	/** zoneSymbol addEventListener */
	const ZONE_SYMBOL_ADD_EVENT_LISTENER = __symbol__(ADD_EVENT_LISTENER_STR);
	/** zoneSymbol removeEventListener */
	const ZONE_SYMBOL_REMOVE_EVENT_LISTENER = __symbol__(REMOVE_EVENT_LISTENER_STR);
	/** true string const */
	const TRUE_STR = 'true';
	/** false string const */
	const FALSE_STR = 'false';
	/** Zone symbol prefix string const. */
	const ZONE_SYMBOL_PREFIX = __symbol__('');
	function wrapWithCurrentZone(callback, source) {
	    return Zone.current.wrap(callback, source);
	}
	function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
	    return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
	}
	const zoneSymbol = __symbol__;
	const isWindowExists = typeof window !== 'undefined';
	const internalWindow = isWindowExists ? window : undefined;
	const _global = (isWindowExists && internalWindow) || globalThis;
	const REMOVE_ATTRIBUTE = 'removeAttribute';
	function bindArguments(args, source) {
	    for (let i = args.length - 1; i >= 0; i--) {
	        if (typeof args[i] === 'function') {
	            args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
	        }
	    }
	    return args;
	}
	function patchPrototype(prototype, fnNames) {
	    const source = prototype.constructor['name'];
	    for (let i = 0; i < fnNames.length; i++) {
	        const name = fnNames[i];
	        const delegate = prototype[name];
	        if (delegate) {
	            const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);
	            if (!isPropertyWritable(prototypeDesc)) {
	                continue;
	            }
	            prototype[name] = ((delegate) => {
	                const patched = function () {
	                    return delegate.apply(this, bindArguments(arguments, source + '.' + name));
	                };
	                attachOriginToPatched(patched, delegate);
	                return patched;
	            })(delegate);
	        }
	    }
	}
	function isPropertyWritable(propertyDesc) {
	    if (!propertyDesc) {
	        return true;
	    }
	    if (propertyDesc.writable === false) {
	        return false;
	    }
	    return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
	}
	const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
	// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
	// this code.
	const isNode = !('nw' in _global) &&
	    typeof _global.process !== 'undefined' &&
	    _global.process.toString() === '[object process]';
	const isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
	// we are in electron of nw, so we are both browser and nodejs
	// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
	// this code.
	const isMix = typeof _global.process !== 'undefined' &&
	    _global.process.toString() === '[object process]' &&
	    !isWebWorker &&
	    !!(isWindowExists && internalWindow['HTMLElement']);
	const zoneSymbolEventNames$1 = {};
	const enableBeforeunloadSymbol = zoneSymbol('enable_beforeunload');
	const wrapFn = function (event) {
	    // https://github.com/angular/zone.js/issues/911, in IE, sometimes
	    // event will be undefined, so we need to use window.event
	    event = event || _global.event;
	    if (!event) {
	        return;
	    }
	    let eventNameSymbol = zoneSymbolEventNames$1[event.type];
	    if (!eventNameSymbol) {
	        eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
	    }
	    const target = this || event.target || _global;
	    const listener = target[eventNameSymbol];
	    let result;
	    if (isBrowser && target === internalWindow && event.type === 'error') {
	        // window.onerror have different signature
	        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
	        // and onerror callback will prevent default when callback return true
	        const errorEvent = event;
	        result =
	            listener &&
	                listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);
	        if (result === true) {
	            event.preventDefault();
	        }
	    }
	    else {
	        result = listener && listener.apply(this, arguments);
	        if (
	        // https://github.com/angular/angular/issues/47579
	        // https://www.w3.org/TR/2011/WD-html5-20110525/history.html#beforeunloadevent
	        // This is the only specific case we should check for. The spec defines that the
	        // `returnValue` attribute represents the message to show the user. When the event
	        // is created, this attribute must be set to the empty string.
	        event.type === 'beforeunload' &&
	            // To prevent any breaking changes resulting from this change, given that
	            // it was already causing a significant number of failures in G3, we have hidden
	            // that behavior behind a global configuration flag. Consumers can enable this
	            // flag explicitly if they want the `beforeunload` event to be handled as defined
	            // in the specification.
	            _global[enableBeforeunloadSymbol] &&
	            // The IDL event definition is `attribute DOMString returnValue`, so we check whether
	            // `typeof result` is a string.
	            typeof result === 'string') {
	            event.returnValue = result;
	        }
	        else if (result != undefined && !result) {
	            event.preventDefault();
	        }
	    }
	    return result;
	};
	function patchProperty(obj, prop, prototype) {
	    let desc = ObjectGetOwnPropertyDescriptor(obj, prop);
	    if (!desc && prototype) {
	        // when patch window object, use prototype to check prop exist or not
	        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);
	        if (prototypeDesc) {
	            desc = { enumerable: true, configurable: true };
	        }
	    }
	    // if the descriptor not exists or is not configurable
	    // just return
	    if (!desc || !desc.configurable) {
	        return;
	    }
	    const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');
	    if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
	        return;
	    }
	    // A property descriptor cannot have getter/setter and be writable
	    // deleting the writable and value properties avoids this error:
	    //
	    // TypeError: property descriptors must not specify a value or be writable when a
	    // getter or setter has been specified
	    delete desc.writable;
	    delete desc.value;
	    const originalDescGet = desc.get;
	    const originalDescSet = desc.set;
	    // slice(2) cuz 'onclick' -> 'click', etc
	    const eventName = prop.slice(2);
	    let eventNameSymbol = zoneSymbolEventNames$1[eventName];
	    if (!eventNameSymbol) {
	        eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
	    }
	    desc.set = function (newValue) {
	        // in some of windows's onproperty callback, this is undefined
	        // so we need to check it
	        let target = this;
	        if (!target && obj === _global) {
	            target = _global;
	        }
	        if (!target) {
	            return;
	        }
	        const previousValue = target[eventNameSymbol];
	        if (typeof previousValue === 'function') {
	            target.removeEventListener(eventName, wrapFn);
	        }
	        // issue #978, when onload handler was added before loading zone.js
	        // we should remove it with originalDescSet
	        originalDescSet && originalDescSet.call(target, null);
	        target[eventNameSymbol] = newValue;
	        if (typeof newValue === 'function') {
	            target.addEventListener(eventName, wrapFn, false);
	        }
	    };
	    // The getter would return undefined for unassigned properties but the default value of an
	    // unassigned property is null
	    desc.get = function () {
	        // in some of windows's onproperty callback, this is undefined
	        // so we need to check it
	        let target = this;
	        if (!target && obj === _global) {
	            target = _global;
	        }
	        if (!target) {
	            return null;
	        }
	        const listener = target[eventNameSymbol];
	        if (listener) {
	            return listener;
	        }
	        else if (originalDescGet) {
	            // result will be null when use inline event attribute,
	            // such as <button onclick="func();">OK</button>
	            // because the onclick function is internal raw uncompiled handler
	            // the onclick will be evaluated when first time event was triggered or
	            // the property is accessed, https://github.com/angular/zone.js/issues/525
	            // so we should use original native get to retrieve the handler
	            let value = originalDescGet.call(this);
	            if (value) {
	                desc.set.call(this, value);
	                if (typeof target[REMOVE_ATTRIBUTE] === 'function') {
	                    target.removeAttribute(prop);
	                }
	                return value;
	            }
	        }
	        return null;
	    };
	    ObjectDefineProperty(obj, prop, desc);
	    obj[onPropPatchedSymbol] = true;
	}
	function patchOnProperties(obj, properties, prototype) {
	    if (properties) {
	        for (let i = 0; i < properties.length; i++) {
	            patchProperty(obj, 'on' + properties[i], prototype);
	        }
	    }
	    else {
	        const onProperties = [];
	        for (const prop in obj) {
	            if (prop.slice(0, 2) == 'on') {
	                onProperties.push(prop);
	            }
	        }
	        for (let j = 0; j < onProperties.length; j++) {
	            patchProperty(obj, onProperties[j], prototype);
	        }
	    }
	}
	const originalInstanceKey = zoneSymbol('originalInstance');
	// wrap some native API on `window`
	function patchClass(className) {
	    const OriginalClass = _global[className];
	    if (!OriginalClass)
	        return;
	    // keep original class in global
	    _global[zoneSymbol(className)] = OriginalClass;
	    _global[className] = function () {
	        const a = bindArguments(arguments, className);
	        switch (a.length) {
	            case 0:
	                this[originalInstanceKey] = new OriginalClass();
	                break;
	            case 1:
	                this[originalInstanceKey] = new OriginalClass(a[0]);
	                break;
	            case 2:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
	                break;
	            case 3:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
	                break;
	            case 4:
	                this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
	                break;
	            default:
	                throw new Error('Arg list too long.');
	        }
	    };
	    // attach original delegate to patched function
	    attachOriginToPatched(_global[className], OriginalClass);
	    const instance = new OriginalClass(function () { });
	    let prop;
	    for (prop in instance) {
	        // https://bugs.webkit.org/show_bug.cgi?id=44721
	        if (className === 'XMLHttpRequest' && prop === 'responseBlob')
	            continue;
	        (function (prop) {
	            if (typeof instance[prop] === 'function') {
	                _global[className].prototype[prop] = function () {
	                    return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
	                };
	            }
	            else {
	                ObjectDefineProperty(_global[className].prototype, prop, {
	                    set: function (fn) {
	                        if (typeof fn === 'function') {
	                            this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop);
	                            // keep callback in wrapped function so we can
	                            // use it in Function.prototype.toString to return
	                            // the native one.
	                            attachOriginToPatched(this[originalInstanceKey][prop], fn);
	                        }
	                        else {
	                            this[originalInstanceKey][prop] = fn;
	                        }
	                    },
	                    get: function () {
	                        return this[originalInstanceKey][prop];
	                    },
	                });
	            }
	        })(prop);
	    }
	    for (prop in OriginalClass) {
	        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
	            _global[className][prop] = OriginalClass[prop];
	        }
	    }
	}
	function patchMethod(target, name, patchFn) {
	    let proto = target;
	    while (proto && !proto.hasOwnProperty(name)) {
	        proto = ObjectGetPrototypeOf(proto);
	    }
	    if (!proto && target[name]) {
	        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
	        proto = target;
	    }
	    const delegateName = zoneSymbol(name);
	    let delegate = null;
	    if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
	        delegate = proto[delegateName] = proto[name];
	        // check whether proto[name] is writable
	        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob
	        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);
	        if (isPropertyWritable(desc)) {
	            const patchDelegate = patchFn(delegate, delegateName, name);
	            proto[name] = function () {
	                return patchDelegate(this, arguments);
	            };
	            attachOriginToPatched(proto[name], delegate);
	        }
	    }
	    return delegate;
	}
	// TODO: @JiaLiPassion, support cancel task later if necessary
	function patchMacroTask(obj, funcName, metaCreator) {
	    let setNative = null;
	    function scheduleTask(task) {
	        const data = task.data;
	        data.args[data.cbIdx] = function () {
	            task.invoke.apply(this, arguments);
	        };
	        setNative.apply(data.target, data.args);
	        return task;
	    }
	    setNative = patchMethod(obj, funcName, (delegate) => function (self, args) {
	        const meta = metaCreator(self, args);
	        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {
	            return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
	        }
	        else {
	            // cause an error by calling it directly.
	            return delegate.apply(self, args);
	        }
	    });
	}
	function attachOriginToPatched(patched, original) {
	    patched[zoneSymbol('OriginalDelegate')] = original;
	}
	let isDetectedIEOrEdge = false;
	let ieOrEdge = false;
	function isIE() {
	    try {
	        const ua = internalWindow.navigator.userAgent;
	        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {
	            return true;
	        }
	    }
	    catch (error) { }
	    return false;
	}
	function isIEOrEdge() {
	    if (isDetectedIEOrEdge) {
	        return ieOrEdge;
	    }
	    isDetectedIEOrEdge = true;
	    try {
	        const ua = internalWindow.navigator.userAgent;
	        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
	            ieOrEdge = true;
	        }
	    }
	    catch (error) { }
	    return ieOrEdge;
	}
	function isFunction(value) {
	    return typeof value === 'function';
	}
	function isNumber(value) {
	    return typeof value === 'number';
	}

	/**
	 * @fileoverview
	 * @suppress {missingRequire}
	 */
	// Note that passive event listeners are now supported by most modern browsers,
	// including Chrome, Firefox, Safari, and Edge. There's a pending change that
	// would remove support for legacy browsers by zone.js. Removing `passiveSupported`
	// from the codebase will reduce the final code size for existing apps that still use zone.js.
	let passiveSupported = false;
	if (typeof window !== 'undefined') {
	    try {
	        const options = Object.defineProperty({}, 'passive', {
	            get: function () {
	                passiveSupported = true;
	            },
	        });
	        // Note: We pass the `options` object as the event handler too. This is not compatible with the
	        // signature of `addEventListener` or `removeEventListener` but enables us to remove the handler
	        // without an actual handler.
	        window.addEventListener('test', options, options);
	        window.removeEventListener('test', options, options);
	    }
	    catch (err) {
	        passiveSupported = false;
	    }
	}
	// an identifier to tell ZoneTask do not create a new invoke closure
	const OPTIMIZED_ZONE_EVENT_TASK_DATA = {
	    useG: true,
	};
	const zoneSymbolEventNames = {};
	const globalSources = {};
	const EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\w+)(true|false)$');
	const IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');
	function prepareEventNames(eventName, eventNameToString) {
	    const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
	    const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
	    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
	    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
	    zoneSymbolEventNames[eventName] = {};
	    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
	    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
	}
	function patchEventTarget(_global, api, apis, patchOptions) {
	    const ADD_EVENT_LISTENER = (patchOptions && patchOptions.add) || ADD_EVENT_LISTENER_STR;
	    const REMOVE_EVENT_LISTENER = (patchOptions && patchOptions.rm) || REMOVE_EVENT_LISTENER_STR;
	    const LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.listeners) || 'eventListeners';
	    const REMOVE_ALL_LISTENERS_EVENT_LISTENER = (patchOptions && patchOptions.rmAll) || 'removeAllListeners';
	    const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
	    const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
	    const PREPEND_EVENT_LISTENER = 'prependListener';
	    const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';
	    const invokeTask = function (task, target, event) {
	        // for better performance, check isRemoved which is set
	        // by removeEventListener
	        if (task.isRemoved) {
	            return;
	        }
	        const delegate = task.callback;
	        if (typeof delegate === 'object' && delegate.handleEvent) {
	            // create the bind version of handleEvent when invoke
	            task.callback = (event) => delegate.handleEvent(event);
	            task.originalDelegate = delegate;
	        }
	        // invoke static task.invoke
	        // need to try/catch error here, otherwise, the error in one event listener
	        // will break the executions of the other event listeners. Also error will
	        // not remove the event listener when `once` options is true.
	        let error;
	        try {
	            task.invoke(task, target, [event]);
	        }
	        catch (err) {
	            error = err;
	        }
	        const options = task.options;
	        if (options && typeof options === 'object' && options.once) {
	            // if options.once is true, after invoke once remove listener here
	            // only browser need to do this, nodejs eventEmitter will cal removeListener
	            // inside EventEmitter.once
	            const delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	            target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);
	        }
	        return error;
	    };
	    function globalCallback(context, event, isCapture) {
	        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
	        // event will be undefined, so we need to use window.event
	        event = event || _global.event;
	        if (!event) {
	            return;
	        }
	        // event.target is needed for Samsung TV and SourceBuffer
	        // || global is needed https://github.com/angular/zone.js/issues/190
	        const target = context || event.target || _global;
	        const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];
	        if (tasks) {
	            const errors = [];
	            // invoke all tasks which attached to current target with given event.type and capture = false
	            // for performance concern, if task.length === 1, just invoke
	            if (tasks.length === 1) {
	                const err = invokeTask(tasks[0], target, event);
	                err && errors.push(err);
	            }
	            else {
	                // https://github.com/angular/zone.js/issues/836
	                // copy the tasks array before invoke, to avoid
	                // the callback will remove itself or other listener
	                const copyTasks = tasks.slice();
	                for (let i = 0; i < copyTasks.length; i++) {
	                    if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
	                        break;
	                    }
	                    const err = invokeTask(copyTasks[i], target, event);
	                    err && errors.push(err);
	                }
	            }
	            // Since there is only one error, we don't need to schedule microTask
	            // to throw the error.
	            if (errors.length === 1) {
	                throw errors[0];
	            }
	            else {
	                for (let i = 0; i < errors.length; i++) {
	                    const err = errors[i];
	                    api.nativeScheduleMicroTask(() => {
	                        throw err;
	                    });
	                }
	            }
	        }
	    }
	    // global shared zoneAwareCallback to handle all event callback with capture = false
	    const globalZoneAwareCallback = function (event) {
	        return globalCallback(this, event, false);
	    };
	    // global shared zoneAwareCallback to handle all event callback with capture = true
	    const globalZoneAwareCaptureCallback = function (event) {
	        return globalCallback(this, event, true);
	    };
	    function patchEventTargetMethods(obj, patchOptions) {
	        if (!obj) {
	            return false;
	        }
	        let useGlobalCallback = true;
	        if (patchOptions && patchOptions.useG !== undefined) {
	            useGlobalCallback = patchOptions.useG;
	        }
	        const validateHandler = patchOptions && patchOptions.vh;
	        let checkDuplicate = true;
	        if (patchOptions && patchOptions.chkDup !== undefined) {
	            checkDuplicate = patchOptions.chkDup;
	        }
	        let returnTarget = false;
	        if (patchOptions && patchOptions.rt !== undefined) {
	            returnTarget = patchOptions.rt;
	        }
	        let proto = obj;
	        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
	            proto = ObjectGetPrototypeOf(proto);
	        }
	        if (!proto && obj[ADD_EVENT_LISTENER]) {
	            // somehow we did not find it, but we can see it. This happens on IE for Window properties.
	            proto = obj;
	        }
	        if (!proto) {
	            return false;
	        }
	        if (proto[zoneSymbolAddEventListener]) {
	            return false;
	        }
	        const eventNameToString = patchOptions && patchOptions.eventNameToString;
	        // We use a shared global `taskData` to pass data for `scheduleEventTask`,
	        // eliminating the need to create a new object solely for passing data.
	        // WARNING: This object has a static lifetime, meaning it is not created
	        // each time `addEventListener` is called. It is instantiated only once
	        // and captured by reference inside the `addEventListener` and
	        // `removeEventListener` functions. Do not add any new properties to this
	        // object, as doing so would necessitate maintaining the information
	        // between `addEventListener` calls.
	        const taskData = {};
	        const nativeAddEventListener = (proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER]);
	        const nativeRemoveEventListener = (proto[zoneSymbol(REMOVE_EVENT_LISTENER)] =
	            proto[REMOVE_EVENT_LISTENER]);
	        const nativeListeners = (proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] =
	            proto[LISTENERS_EVENT_LISTENER]);
	        const nativeRemoveAllListeners = (proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] =
	            proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER]);
	        let nativePrependEventListener;
	        if (patchOptions && patchOptions.prepend) {
	            nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] =
	                proto[patchOptions.prepend];
	        }
	        /**
	         * This util function will build an option object with passive option
	         * to handle all possible input from the user.
	         */
	        function buildEventListenerOptions(options, passive) {
	            if (!passiveSupported && typeof options === 'object' && options) {
	                // doesn't support passive but user want to pass an object as options.
	                // this will not work on some old browser, so we just pass a boolean
	                // as useCapture parameter
	                return !!options.capture;
	            }
	            if (!passiveSupported || !passive) {
	                return options;
	            }
	            if (typeof options === 'boolean') {
	                return { capture: options, passive: true };
	            }
	            if (!options) {
	                return { passive: true };
	            }
	            if (typeof options === 'object' && options.passive !== false) {
	                return { ...options, passive: true };
	            }
	            return options;
	        }
	        const customScheduleGlobal = function (task) {
	            // if there is already a task for the eventName + capture,
	            // just return, because we use the shared globalZoneAwareCallback here.
	            if (taskData.isExisting) {
	                return;
	            }
	            return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
	        };
	        /**
	         * In the context of events and listeners, this function will be
	         * called at the end by `cancelTask`, which, in turn, calls `task.cancelFn`.
	         * Cancelling a task is primarily used to remove event listeners from
	         * the task target.
	         */
	        const customCancelGlobal = function (task) {
	            // if task is not marked as isRemoved, this call is directly
	            // from Zone.prototype.cancelTask, we should remove the task
	            // from tasksList of target first
	            if (!task.isRemoved) {
	                const symbolEventNames = zoneSymbolEventNames[task.eventName];
	                let symbolEventName;
	                if (symbolEventNames) {
	                    symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
	                }
	                const existingTasks = symbolEventName && task.target[symbolEventName];
	                if (existingTasks) {
	                    for (let i = 0; i < existingTasks.length; i++) {
	                        const existingTask = existingTasks[i];
	                        if (existingTask === task) {
	                            existingTasks.splice(i, 1);
	                            // set isRemoved to data for faster invokeTask check
	                            task.isRemoved = true;
	                            if (task.removeAbortListener) {
	                                task.removeAbortListener();
	                                task.removeAbortListener = null;
	                            }
	                            if (existingTasks.length === 0) {
	                                // all tasks for the eventName + capture have gone,
	                                // remove globalZoneAwareCallback and remove the task cache from target
	                                task.allRemoved = true;
	                                task.target[symbolEventName] = null;
	                            }
	                            break;
	                        }
	                    }
	                }
	            }
	            // if all tasks for the eventName + capture have gone,
	            // we will really remove the global event callback,
	            // if not, return
	            if (!task.allRemoved) {
	                return;
	            }
	            return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
	        };
	        const customScheduleNonGlobal = function (task) {
	            return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
	        };
	        const customSchedulePrepend = function (task) {
	            return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
	        };
	        const customCancelNonGlobal = function (task) {
	            return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
	        };
	        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
	        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;
	        const compareTaskCallbackVsDelegate = function (task, delegate) {
	            const typeOfDelegate = typeof delegate;
	            return ((typeOfDelegate === 'function' && task.callback === delegate) ||
	                (typeOfDelegate === 'object' && task.originalDelegate === delegate));
	        };
	        const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;
	        const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];
	        const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];
	        function copyEventListenerOptions(options) {
	            if (typeof options === 'object' && options !== null) {
	                // We need to destructure the target `options` object since it may
	                // be frozen or sealed (possibly provided implicitly by a third-party
	                // library), or its properties may be readonly.
	                const newOptions = { ...options };
	                // The `signal` option was recently introduced, which caused regressions in
	                // third-party scenarios where `AbortController` was directly provided to
	                // `addEventListener` as options. For instance, in cases like
	                // `document.addEventListener('keydown', callback, abortControllerInstance)`,
	                // which is valid because `AbortController` includes a `signal` getter, spreading
	                // `{...options}` wouldn't copy the `signal`. Additionally, using `Object.create`
	                // isn't feasible since `AbortController` is a built-in object type, and attempting
	                // to create a new object directly with it as the prototype might result in
	                // unexpected behavior.
	                if (options.signal) {
	                    newOptions.signal = options.signal;
	                }
	                return newOptions;
	            }
	            return options;
	        }
	        const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {
	            return function () {
	                const target = this || _global;
	                let eventName = arguments[0];
	                if (patchOptions && patchOptions.transferEventName) {
	                    eventName = patchOptions.transferEventName(eventName);
	                }
	                let delegate = arguments[1];
	                if (!delegate) {
	                    return nativeListener.apply(this, arguments);
	                }
	                if (isNode && eventName === 'uncaughtException') {
	                    // don't patch uncaughtException of nodejs to prevent endless loop
	                    return nativeListener.apply(this, arguments);
	                }
	                // don't create the bind delegate function for handleEvent
	                // case here to improve addEventListener performance
	                // we will create the bind delegate when invoke
	                let isHandleEvent = false;
	                if (typeof delegate !== 'function') {
	                    if (!delegate.handleEvent) {
	                        return nativeListener.apply(this, arguments);
	                    }
	                    isHandleEvent = true;
	                }
	                if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
	                    return;
	                }
	                const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
	                const options = copyEventListenerOptions(buildEventListenerOptions(arguments[2], passive));
	                const signal = options?.signal;
	                if (signal?.aborted) {
	                    // the signal is an aborted one, just return without attaching the event listener.
	                    return;
	                }
	                if (unpatchedEvents) {
	                    // check unpatched list
	                    for (let i = 0; i < unpatchedEvents.length; i++) {
	                        if (eventName === unpatchedEvents[i]) {
	                            if (passive) {
	                                return nativeListener.call(target, eventName, delegate, options);
	                            }
	                            else {
	                                return nativeListener.apply(this, arguments);
	                            }
	                        }
	                    }
	                }
	                const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
	                const once = options && typeof options === 'object' ? options.once : false;
	                const zone = Zone.current;
	                let symbolEventNames = zoneSymbolEventNames[eventName];
	                if (!symbolEventNames) {
	                    prepareEventNames(eventName, eventNameToString);
	                    symbolEventNames = zoneSymbolEventNames[eventName];
	                }
	                const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
	                let existingTasks = target[symbolEventName];
	                let isExisting = false;
	                if (existingTasks) {
	                    // already have task registered
	                    isExisting = true;
	                    if (checkDuplicate) {
	                        for (let i = 0; i < existingTasks.length; i++) {
	                            if (compare(existingTasks[i], delegate)) {
	                                // same callback, same capture, same event name, just return
	                                return;
	                            }
	                        }
	                    }
	                }
	                else {
	                    existingTasks = target[symbolEventName] = [];
	                }
	                let source;
	                const constructorName = target.constructor['name'];
	                const targetSource = globalSources[constructorName];
	                if (targetSource) {
	                    source = targetSource[eventName];
	                }
	                if (!source) {
	                    source =
	                        constructorName +
	                            addSource +
	                            (eventNameToString ? eventNameToString(eventName) : eventName);
	                }
	                // In the code below, `options` should no longer be reassigned; instead, it
	                // should only be mutated. This is because we pass that object to the native
	                // `addEventListener`.
	                // It's generally recommended to use the same object reference for options.
	                // This ensures consistency and avoids potential issues.
	                taskData.options = options;
	                if (once) {
	                    // When using `addEventListener` with the `once` option, we don't pass
	                    // the `once` option directly to the native `addEventListener` method.
	                    // Instead, we keep the `once` setting and handle it ourselves.
	                    taskData.options.once = false;
	                }
	                taskData.target = target;
	                taskData.capture = capture;
	                taskData.eventName = eventName;
	                taskData.isExisting = isExisting;
	                const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined;
	                // keep taskData into data to allow onScheduleEventTask to access the task information
	                if (data) {
	                    data.taskData = taskData;
	                }
	                if (signal) {
	                    // When using `addEventListener` with the `signal` option, we don't pass
	                    // the `signal` option directly to the native `addEventListener` method.
	                    // Instead, we keep the `signal` setting and handle it ourselves.
	                    taskData.options.signal = undefined;
	                }
	                // The `scheduleEventTask` function will ultimately call `customScheduleGlobal`,
	                // which in turn calls the native `addEventListener`. This is why `taskData.options`
	                // is updated before scheduling the task, as `customScheduleGlobal` uses
	                // `taskData.options` to pass it to the native `addEventListener`.
	                const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn);
	                if (signal) {
	                    // after task is scheduled, we need to store the signal back to task.options
	                    taskData.options.signal = signal;
	                    // Wrapping `task` in a weak reference would not prevent memory leaks. Weak references are
	                    // primarily used for preventing strong references cycles. `onAbort` is always reachable
	                    // as it's an event listener, so its closure retains a strong reference to the `task`.
	                    const onAbort = () => task.zone.cancelTask(task);
	                    nativeListener.call(signal, 'abort', onAbort, { once: true });
	                    // We need to remove the `abort` listener when the event listener is going to be removed,
	                    // as it creates a closure that captures `task`. This closure retains a reference to the
	                    // `task` object even after it goes out of scope, preventing `task` from being garbage
	                    // collected.
	                    task.removeAbortListener = () => signal.removeEventListener('abort', onAbort);
	                }
	                // should clear taskData.target to avoid memory leak
	                // issue, https://github.com/angular/angular/issues/20442
	                taskData.target = null;
	                // need to clear up taskData because it is a global object
	                if (data) {
	                    data.taskData = null;
	                }
	                // have to save those information to task in case
	                // application may call task.zone.cancelTask() directly
	                if (once) {
	                    taskData.options.once = true;
	                }
	                if (!(!passiveSupported && typeof task.options === 'boolean')) {
	                    // if not support passive, and we pass an option object
	                    // to addEventListener, we should save the options to task
	                    task.options = options;
	                }
	                task.target = target;
	                task.capture = capture;
	                task.eventName = eventName;
	                if (isHandleEvent) {
	                    // save original delegate for compare to check duplicate
	                    task.originalDelegate = delegate;
	                }
	                if (!prepend) {
	                    existingTasks.push(task);
	                }
	                else {
	                    existingTasks.unshift(task);
	                }
	                if (returnTarget) {
	                    return target;
	                }
	            };
	        };
	        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);
	        if (nativePrependEventListener) {
	            proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
	        }
	        proto[REMOVE_EVENT_LISTENER] = function () {
	            const target = this || _global;
	            let eventName = arguments[0];
	            if (patchOptions && patchOptions.transferEventName) {
	                eventName = patchOptions.transferEventName(eventName);
	            }
	            const options = arguments[2];
	            const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
	            const delegate = arguments[1];
	            if (!delegate) {
	                return nativeRemoveEventListener.apply(this, arguments);
	            }
	            if (validateHandler &&
	                !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
	                return;
	            }
	            const symbolEventNames = zoneSymbolEventNames[eventName];
	            let symbolEventName;
	            if (symbolEventNames) {
	                symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
	            }
	            const existingTasks = symbolEventName && target[symbolEventName];
	            // `existingTasks` may not exist if the `addEventListener` was called before
	            // it was patched by zone.js. Please refer to the attached issue for
	            // clarification, particularly after the `if` condition, before calling
	            // the native `removeEventListener`.
	            if (existingTasks) {
	                for (let i = 0; i < existingTasks.length; i++) {
	                    const existingTask = existingTasks[i];
	                    if (compare(existingTask, delegate)) {
	                        existingTasks.splice(i, 1);
	                        // set isRemoved to data for faster invokeTask check
	                        existingTask.isRemoved = true;
	                        if (existingTasks.length === 0) {
	                            // all tasks for the eventName + capture have gone,
	                            // remove globalZoneAwareCallback and remove the task cache from target
	                            existingTask.allRemoved = true;
	                            target[symbolEventName] = null;
	                            // in the target, we have an event listener which is added by on_property
	                            // such as target.onclick = function() {}, so we need to clear this internal
	                            // property too if all delegates with capture=false were removed
	                            // https:// github.com/angular/angular/issues/31643
	                            // https://github.com/angular/angular/issues/54581
	                            if (!capture && typeof eventName === 'string') {
	                                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;
	                                target[onPropertySymbol] = null;
	                            }
	                        }
	                        // In all other conditions, when `addEventListener` is called after being
	                        // patched by zone.js, we would always find an event task on the `EventTarget`.
	                        // This will trigger `cancelFn` on the `existingTask`, leading to `customCancelGlobal`,
	                        // which ultimately removes an event listener and cleans up the abort listener
	                        // (if an `AbortSignal` was provided when scheduling a task).
	                        existingTask.zone.cancelTask(existingTask);
	                        if (returnTarget) {
	                            return target;
	                        }
	                        return;
	                    }
	                }
	            }
	            // https://github.com/angular/zone.js/issues/930
	            // We may encounter a situation where the `addEventListener` was
	            // called on the event target before zone.js is loaded, resulting
	            // in no task being stored on the event target due to its invocation
	            // of the native implementation. In this scenario, we simply need to
	            // invoke the native `removeEventListener`.
	            return nativeRemoveEventListener.apply(this, arguments);
	        };
	        proto[LISTENERS_EVENT_LISTENER] = function () {
	            const target = this || _global;
	            let eventName = arguments[0];
	            if (patchOptions && patchOptions.transferEventName) {
	                eventName = patchOptions.transferEventName(eventName);
	            }
	            const listeners = [];
	            const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);
	            for (let i = 0; i < tasks.length; i++) {
	                const task = tasks[i];
	                let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                listeners.push(delegate);
	            }
	            return listeners;
	        };
	        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
	            const target = this || _global;
	            let eventName = arguments[0];
	            if (!eventName) {
	                const keys = Object.keys(target);
	                for (let i = 0; i < keys.length; i++) {
	                    const prop = keys[i];
	                    const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
	                    let evtName = match && match[1];
	                    // in nodejs EventEmitter, removeListener event is
	                    // used for monitoring the removeListener call,
	                    // so just keep removeListener eventListener until
	                    // all other eventListeners are removed
	                    if (evtName && evtName !== 'removeListener') {
	                        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
	                    }
	                }
	                // remove removeListener listener finally
	                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
	            }
	            else {
	                if (patchOptions && patchOptions.transferEventName) {
	                    eventName = patchOptions.transferEventName(eventName);
	                }
	                const symbolEventNames = zoneSymbolEventNames[eventName];
	                if (symbolEventNames) {
	                    const symbolEventName = symbolEventNames[FALSE_STR];
	                    const symbolCaptureEventName = symbolEventNames[TRUE_STR];
	                    const tasks = target[symbolEventName];
	                    const captureTasks = target[symbolCaptureEventName];
	                    if (tasks) {
	                        const removeTasks = tasks.slice();
	                        for (let i = 0; i < removeTasks.length; i++) {
	                            const task = removeTasks[i];
	                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
	                        }
	                    }
	                    if (captureTasks) {
	                        const removeTasks = captureTasks.slice();
	                        for (let i = 0; i < removeTasks.length; i++) {
	                            const task = removeTasks[i];
	                            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
	                            this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
	                        }
	                    }
	                }
	            }
	            if (returnTarget) {
	                return this;
	            }
	        };
	        // for native toString patch
	        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
	        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);
	        if (nativeRemoveAllListeners) {
	            attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
	        }
	        if (nativeListeners) {
	            attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
	        }
	        return true;
	    }
	    let results = [];
	    for (let i = 0; i < apis.length; i++) {
	        results[i] = patchEventTargetMethods(apis[i], patchOptions);
	    }
	    return results;
	}
	function findEventTasks(target, eventName) {
	    if (!eventName) {
	        const foundTasks = [];
	        for (let prop in target) {
	            const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
	            let evtName = match && match[1];
	            if (evtName && (!eventName || evtName === eventName)) {
	                const tasks = target[prop];
	                if (tasks) {
	                    for (let i = 0; i < tasks.length; i++) {
	                        foundTasks.push(tasks[i]);
	                    }
	                }
	            }
	        }
	        return foundTasks;
	    }
	    let symbolEventName = zoneSymbolEventNames[eventName];
	    if (!symbolEventName) {
	        prepareEventNames(eventName);
	        symbolEventName = zoneSymbolEventNames[eventName];
	    }
	    const captureFalseTasks = target[symbolEventName[FALSE_STR]];
	    const captureTrueTasks = target[symbolEventName[TRUE_STR]];
	    if (!captureFalseTasks) {
	        return captureTrueTasks ? captureTrueTasks.slice() : [];
	    }
	    else {
	        return captureTrueTasks
	            ? captureFalseTasks.concat(captureTrueTasks)
	            : captureFalseTasks.slice();
	    }
	}
	function patchEventPrototype(global, api) {
	    const Event = global['Event'];
	    if (Event && Event.prototype) {
	        api.patchMethod(Event.prototype, 'stopImmediatePropagation', (delegate) => function (self, args) {
	            self[IMMEDIATE_PROPAGATION_SYMBOL] = true;
	            // we need to call the native stopImmediatePropagation
	            // in case in some hybrid application, some part of
	            // application will be controlled by zone, some are not
	            delegate && delegate.apply(self, args);
	        });
	    }
	}

	/**
	 * @fileoverview
	 * @suppress {missingRequire}
	 */
	function patchQueueMicrotask(global, api) {
	    api.patchMethod(global, 'queueMicrotask', (delegate) => {
	        return function (self, args) {
	            Zone.current.scheduleMicroTask('queueMicrotask', args[0]);
	        };
	    });
	}

	/**
	 * @fileoverview
	 * @suppress {missingRequire}
	 */
	const taskSymbol = zoneSymbol('zoneTask');
	function patchTimer(window, setName, cancelName, nameSuffix) {
	    let setNative = null;
	    let clearNative = null;
	    setName += nameSuffix;
	    cancelName += nameSuffix;
	    const tasksByHandleId = {};
	    function scheduleTask(task) {
	        const data = task.data;
	        data.args[0] = function () {
	            return task.invoke.apply(this, arguments);
	        };
	        const handleOrId = setNative.apply(window, data.args);
	        // Whlist on Node.js when get can the ID by using `[Symbol.toPrimitive]()` we do
	        // to this so that we do not cause potentally leaks when using `setTimeout`
	        // since this can be periodic when using `.refresh`.
	        if (isNumber(handleOrId)) {
	            data.handleId = handleOrId;
	        }
	        else {
	            data.handle = handleOrId;
	            // On Node.js a timeout and interval can be restarted over and over again by using the `.refresh` method.
	            data.isRefreshable = isFunction(handleOrId.refresh);
	        }
	        return task;
	    }
	    function clearTask(task) {
	        const { handle, handleId } = task.data;
	        return clearNative.call(window, handle ?? handleId);
	    }
	    setNative = patchMethod(window, setName, (delegate) => function (self, args) {
	        if (isFunction(args[0])) {
	            const options = {
	                isRefreshable: false,
	                isPeriodic: nameSuffix === 'Interval',
	                delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,
	                args: args,
	            };
	            const callback = args[0];
	            args[0] = function timer() {
	                try {
	                    return callback.apply(this, arguments);
	                }
	                finally {
	                    // issue-934, task will be cancelled
	                    // even it is a periodic task such as
	                    // setInterval
	                    // https://github.com/angular/angular/issues/40387
	                    // Cleanup tasksByHandleId should be handled before scheduleTask
	                    // Since some zoneSpec may intercept and doesn't trigger
	                    // scheduleFn(scheduleTask) provided here.
	                    const { handle, handleId, isPeriodic, isRefreshable } = options;
	                    if (!isPeriodic && !isRefreshable) {
	                        if (handleId) {
	                            // in non-nodejs env, we remove timerId
	                            // from local cache
	                            delete tasksByHandleId[handleId];
	                        }
	                        else if (handle) {
	                            // Node returns complex objects as handleIds
	                            // we remove task reference from timer object
	                            handle[taskSymbol] = null;
	                        }
	                    }
	                }
	            };
	            const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);
	            if (!task) {
	                return task;
	            }
	            // Node.js must additionally support the ref and unref functions.
	            const { handleId, handle, isRefreshable, isPeriodic } = task.data;
	            if (handleId) {
	                // for non nodejs env, we save handleId: task
	                // mapping in local cache for clearTimeout
	                tasksByHandleId[handleId] = task;
	            }
	            else if (handle) {
	                // for nodejs env, we save task
	                // reference in timerId Object for clearTimeout
	                handle[taskSymbol] = task;
	                if (isRefreshable && !isPeriodic) {
	                    const originalRefresh = handle.refresh;
	                    handle.refresh = function () {
	                        const { zone, state } = task;
	                        if (state === 'notScheduled') {
	                            task._state = 'scheduled';
	                            zone._updateTaskCount(task, 1);
	                        }
	                        else if (state === 'running') {
	                            task._state = 'scheduling';
	                        }
	                        return originalRefresh.call(this);
	                    };
	                }
	            }
	            return handle ?? handleId ?? task;
	        }
	        else {
	            // cause an error by calling it directly.
	            return delegate.apply(window, args);
	        }
	    });
	    clearNative = patchMethod(window, cancelName, (delegate) => function (self, args) {
	        const id = args[0];
	        let task;
	        if (isNumber(id)) {
	            // non nodejs env.
	            task = tasksByHandleId[id];
	            delete tasksByHandleId[id];
	        }
	        else {
	            // nodejs env ?? other environments.
	            task = id?.[taskSymbol];
	            if (task) {
	                id[taskSymbol] = null;
	            }
	            else {
	                task = id;
	            }
	        }
	        if (task?.type) {
	            if (task.cancelFn) {
	                // Do not cancel already canceled functions
	                task.zone.cancelTask(task);
	            }
	        }
	        else {
	            // cause an error by calling it directly.
	            delegate.apply(window, args);
	        }
	    });
	}

	function patchCustomElements(_global, api) {
	    const { isBrowser, isMix } = api.getGlobalObjects();
	    if ((!isBrowser && !isMix) || !_global['customElements'] || !('customElements' in _global)) {
	        return;
	    }
	    // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-custom-element-definition-lifecycle-callbacks
	    const callbacks = [
	        'connectedCallback',
	        'disconnectedCallback',
	        'adoptedCallback',
	        'attributeChangedCallback',
	        'formAssociatedCallback',
	        'formDisabledCallback',
	        'formResetCallback',
	        'formStateRestoreCallback',
	    ];
	    api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
	}

	function eventTargetPatch(_global, api) {
	    if (Zone[api.symbol('patchEventTarget')]) {
	        // EventTarget is already patched.
	        return;
	    }
	    const { eventNames, zoneSymbolEventNames, TRUE_STR, FALSE_STR, ZONE_SYMBOL_PREFIX } = api.getGlobalObjects();
	    //  predefine all __zone_symbol__ + eventName + true/false string
	    for (let i = 0; i < eventNames.length; i++) {
	        const eventName = eventNames[i];
	        const falseEventName = eventName + FALSE_STR;
	        const trueEventName = eventName + TRUE_STR;
	        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
	        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
	        zoneSymbolEventNames[eventName] = {};
	        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
	        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
	    }
	    const EVENT_TARGET = _global['EventTarget'];
	    if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
	        return;
	    }
	    api.patchEventTarget(_global, api, [EVENT_TARGET && EVENT_TARGET.prototype]);
	    return true;
	}
	function patchEvent(global, api) {
	    api.patchEventPrototype(global, api);
	}

	/**
	 * @fileoverview
	 * @suppress {globalThis}
	 */
	function filterProperties(target, onProperties, ignoreProperties) {
	    if (!ignoreProperties || ignoreProperties.length === 0) {
	        return onProperties;
	    }
	    const tip = ignoreProperties.filter((ip) => ip.target === target);
	    if (!tip || tip.length === 0) {
	        return onProperties;
	    }
	    const targetIgnoreProperties = tip[0].ignoreProperties;
	    return onProperties.filter((op) => targetIgnoreProperties.indexOf(op) === -1);
	}
	function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
	    // check whether target is available, sometimes target will be undefined
	    // because different browser or some 3rd party plugin.
	    if (!target) {
	        return;
	    }
	    const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
	    patchOnProperties(target, filteredProperties, prototype);
	}
	/**
	 * Get all event name properties which the event name startsWith `on`
	 * from the target object itself, inherited properties are not considered.
	 */
	function getOnEventNames(target) {
	    return Object.getOwnPropertyNames(target)
	        .filter((name) => name.startsWith('on') && name.length > 2)
	        .map((name) => name.substring(2));
	}
	function propertyDescriptorPatch(api, _global) {
	    if (isNode && !isMix) {
	        return;
	    }
	    if (Zone[api.symbol('patchEvents')]) {
	        // events are already been patched by legacy patch.
	        return;
	    }
	    const ignoreProperties = _global['__Zone_ignore_on_properties'];
	    // for browsers that we can patch the descriptor:  Chrome & Firefox
	    let patchTargets = [];
	    if (isBrowser) {
	        const internalWindow = window;
	        patchTargets = patchTargets.concat([
	            'Document',
	            'SVGElement',
	            'Element',
	            'HTMLElement',
	            'HTMLBodyElement',
	            'HTMLMediaElement',
	            'HTMLFrameSetElement',
	            'HTMLFrameElement',
	            'HTMLIFrameElement',
	            'HTMLMarqueeElement',
	            'Worker',
	        ]);
	        const ignoreErrorProperties = isIE()
	            ? [{ target: internalWindow, ignoreProperties: ['error'] }]
	            : [];
	        // in IE/Edge, onProp not exist in window object, but in WindowPrototype
	        // so we need to pass WindowPrototype to check onProp exist or not
	        patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));
	    }
	    patchTargets = patchTargets.concat([
	        'XMLHttpRequest',
	        'XMLHttpRequestEventTarget',
	        'IDBIndex',
	        'IDBRequest',
	        'IDBOpenDBRequest',
	        'IDBDatabase',
	        'IDBTransaction',
	        'IDBCursor',
	        'WebSocket',
	    ]);
	    for (let i = 0; i < patchTargets.length; i++) {
	        const target = _global[patchTargets[i]];
	        target &&
	            target.prototype &&
	            patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);
	    }
	}

	/**
	 * @fileoverview
	 * @suppress {missingRequire}
	 */
	function patchBrowser(Zone) {
	    Zone.__load_patch('legacy', (global) => {
	        const legacyPatch = global[Zone.__symbol__('legacyPatch')];
	        if (legacyPatch) {
	            legacyPatch();
	        }
	    });
	    Zone.__load_patch('timers', (global) => {
	        const set = 'set';
	        const clear = 'clear';
	        patchTimer(global, set, clear, 'Timeout');
	        patchTimer(global, set, clear, 'Interval');
	        patchTimer(global, set, clear, 'Immediate');
	    });
	    Zone.__load_patch('requestAnimationFrame', (global) => {
	        patchTimer(global, 'request', 'cancel', 'AnimationFrame');
	        patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
	        patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
	    });
	    Zone.__load_patch('blocking', (global, Zone) => {
	        const blockingMethods = ['alert', 'prompt', 'confirm'];
	        for (let i = 0; i < blockingMethods.length; i++) {
	            const name = blockingMethods[i];
	            patchMethod(global, name, (delegate, symbol, name) => {
	                return function (s, args) {
	                    return Zone.current.run(delegate, global, args, name);
	                };
	            });
	        }
	    });
	    Zone.__load_patch('EventTarget', (global, Zone, api) => {
	        patchEvent(global, api);
	        eventTargetPatch(global, api);
	        // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener
	        const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];
	        if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
	            api.patchEventTarget(global, api, [XMLHttpRequestEventTarget.prototype]);
	        }
	    });
	    Zone.__load_patch('MutationObserver', (global, Zone, api) => {
	        patchClass('MutationObserver');
	        patchClass('WebKitMutationObserver');
	    });
	    Zone.__load_patch('IntersectionObserver', (global, Zone, api) => {
	        patchClass('IntersectionObserver');
	    });
	    Zone.__load_patch('FileReader', (global, Zone, api) => {
	        patchClass('FileReader');
	    });
	    Zone.__load_patch('on_property', (global, Zone, api) => {
	        propertyDescriptorPatch(api, global);
	    });
	    Zone.__load_patch('customElements', (global, Zone, api) => {
	        patchCustomElements(global, api);
	    });
	    Zone.__load_patch('XHR', (global, Zone) => {
	        // Treat XMLHttpRequest as a macrotask.
	        patchXHR(global);
	        const XHR_TASK = zoneSymbol('xhrTask');
	        const XHR_SYNC = zoneSymbol('xhrSync');
	        const XHR_LISTENER = zoneSymbol('xhrListener');
	        const XHR_SCHEDULED = zoneSymbol('xhrScheduled');
	        const XHR_URL = zoneSymbol('xhrURL');
	        const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');
	        function patchXHR(window) {
	            const XMLHttpRequest = window['XMLHttpRequest'];
	            if (!XMLHttpRequest) {
	                // XMLHttpRequest is not available in service worker
	                return;
	            }
	            const XMLHttpRequestPrototype = XMLHttpRequest.prototype;
	            function findPendingTask(target) {
	                return target[XHR_TASK];
	            }
	            let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
	            let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
	            if (!oriAddListener) {
	                const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];
	                if (XMLHttpRequestEventTarget) {
	                    const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
	                    oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
	                    oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
	                }
	            }
	            const READY_STATE_CHANGE = 'readystatechange';
	            const SCHEDULED = 'scheduled';
	            function scheduleTask(task) {
	                const data = task.data;
	                const target = data.target;
	                target[XHR_SCHEDULED] = false;
	                target[XHR_ERROR_BEFORE_SCHEDULED] = false;
	                // remove existing event listener
	                const listener = target[XHR_LISTENER];
	                if (!oriAddListener) {
	                    oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
	                    oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
	                }
	                if (listener) {
	                    oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
	                }
	                const newListener = (target[XHR_LISTENER] = () => {
	                    if (target.readyState === target.DONE) {
	                        // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
	                        // readyState=4 multiple times, so we need to check task state here
	                        if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
	                            // check whether the xhr has registered onload listener
	                            // if that is the case, the task should invoke after all
	                            // onload listeners finish.
	                            // Also if the request failed without response (status = 0), the load event handler
	                            // will not be triggered, in that case, we should also invoke the placeholder callback
	                            // to close the XMLHttpRequest::send macroTask.
	                            // https://github.com/angular/angular/issues/38795
	                            const loadTasks = target[Zone.__symbol__('loadfalse')];
	                            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
	                                const oriInvoke = task.invoke;
	                                task.invoke = function () {
	                                    // need to load the tasks again, because in other
	                                    // load listener, they may remove themselves
	                                    const loadTasks = target[Zone.__symbol__('loadfalse')];
	                                    for (let i = 0; i < loadTasks.length; i++) {
	                                        if (loadTasks[i] === task) {
	                                            loadTasks.splice(i, 1);
	                                        }
	                                    }
	                                    if (!data.aborted && task.state === SCHEDULED) {
	                                        oriInvoke.call(task);
	                                    }
	                                };
	                                loadTasks.push(task);
	                            }
	                            else {
	                                task.invoke();
	                            }
	                        }
	                        else if (!data.aborted && target[XHR_SCHEDULED] === false) {
	                            // error occurs when xhr.send()
	                            target[XHR_ERROR_BEFORE_SCHEDULED] = true;
	                        }
	                    }
	                });
	                oriAddListener.call(target, READY_STATE_CHANGE, newListener);
	                const storedTask = target[XHR_TASK];
	                if (!storedTask) {
	                    target[XHR_TASK] = task;
	                }
	                sendNative.apply(target, data.args);
	                target[XHR_SCHEDULED] = true;
	                return task;
	            }
	            function placeholderCallback() { }
	            function clearTask(task) {
	                const data = task.data;
	                // Note - ideally, we would call data.target.removeEventListener here, but it's too late
	                // to prevent it from firing. So instead, we store info for the event listener.
	                data.aborted = true;
	                return abortNative.apply(data.target, data.args);
	            }
	            const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {
	                self[XHR_SYNC] = args[2] == false;
	                self[XHR_URL] = args[1];
	                return openNative.apply(self, args);
	            });
	            const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
	            const fetchTaskAborting = zoneSymbol('fetchTaskAborting');
	            const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
	            const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {
	                if (Zone.current[fetchTaskScheduling] === true) {
	                    // a fetch is scheduling, so we are using xhr to polyfill fetch
	                    // and because we already schedule macroTask for fetch, we should
	                    // not schedule a macroTask for xhr again
	                    return sendNative.apply(self, args);
	                }
	                if (self[XHR_SYNC]) {
	                    // if the XHR is sync there is no task to schedule, just execute the code.
	                    return sendNative.apply(self, args);
	                }
	                else {
	                    const options = {
	                        target: self,
	                        url: self[XHR_URL],
	                        isPeriodic: false,
	                        args: args,
	                        aborted: false,
	                    };
	                    const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);
	                    if (self &&
	                        self[XHR_ERROR_BEFORE_SCHEDULED] === true &&
	                        !options.aborted &&
	                        task.state === SCHEDULED) {
	                        // xhr request throw error when send
	                        // we should invoke task instead of leaving a scheduled
	                        // pending macroTask
	                        task.invoke();
	                    }
	                }
	            });
	            const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {
	                const task = findPendingTask(self);
	                if (task && typeof task.type == 'string') {
	                    // If the XHR has already completed, do nothing.
	                    // If the XHR has already been aborted, do nothing.
	                    // Fix #569, call abort multiple times before done will cause
	                    // macroTask task count be negative number
	                    if (task.cancelFn == null || (task.data && task.data.aborted)) {
	                        return;
	                    }
	                    task.zone.cancelTask(task);
	                }
	                else if (Zone.current[fetchTaskAborting] === true) {
	                    // the abort is called from fetch polyfill, we need to call native abort of XHR.
	                    return abortNative.apply(self, args);
	                }
	                // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
	                // task
	                // to cancel. Do nothing.
	            });
	        }
	    });
	    Zone.__load_patch('geolocation', (global) => {
	        /// GEO_LOCATION
	        if (global['navigator'] && global['navigator'].geolocation) {
	            patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
	        }
	    });
	    Zone.__load_patch('PromiseRejectionEvent', (global, Zone) => {
	        // handle unhandled promise rejection
	        function findPromiseRejectionHandler(evtName) {
	            return function (e) {
	                const eventTasks = findEventTasks(global, evtName);
	                eventTasks.forEach((eventTask) => {
	                    // windows has added unhandledrejection event listener
	                    // trigger the event listener
	                    const PromiseRejectionEvent = global['PromiseRejectionEvent'];
	                    if (PromiseRejectionEvent) {
	                        const evt = new PromiseRejectionEvent(evtName, {
	                            promise: e.promise,
	                            reason: e.rejection,
	                        });
	                        eventTask.invoke(evt);
	                    }
	                });
	            };
	        }
	        if (global['PromiseRejectionEvent']) {
	            Zone[zoneSymbol('unhandledPromiseRejectionHandler')] =
	                findPromiseRejectionHandler('unhandledrejection');
	            Zone[zoneSymbol('rejectionHandledHandler')] =
	                findPromiseRejectionHandler('rejectionhandled');
	        }
	    });
	    Zone.__load_patch('queueMicrotask', (global, Zone, api) => {
	        patchQueueMicrotask(global, api);
	    });
	}

	function patchPromise(Zone) {
	    Zone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {
	        const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	        const ObjectDefineProperty = Object.defineProperty;
	        function readableObjectToString(obj) {
	            if (obj && obj.toString === Object.prototype.toString) {
	                const className = obj.constructor && obj.constructor.name;
	                return (className ? className : '') + ': ' + JSON.stringify(obj);
	            }
	            return obj ? obj.toString() : Object.prototype.toString.call(obj);
	        }
	        const __symbol__ = api.symbol;
	        const _uncaughtPromiseErrors = [];
	        const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] !== false;
	        const symbolPromise = __symbol__('Promise');
	        const symbolThen = __symbol__('then');
	        const creationTrace = '__creationTrace__';
	        api.onUnhandledError = (e) => {
	            if (api.showUncaughtError()) {
	                const rejection = e && e.rejection;
	                if (rejection) {
	                    console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
	                }
	                else {
	                    console.error(e);
	                }
	            }
	        };
	        api.microtaskDrainDone = () => {
	            while (_uncaughtPromiseErrors.length) {
	                const uncaughtPromiseError = _uncaughtPromiseErrors.shift();
	                try {
	                    uncaughtPromiseError.zone.runGuarded(() => {
	                        if (uncaughtPromiseError.throwOriginal) {
	                            throw uncaughtPromiseError.rejection;
	                        }
	                        throw uncaughtPromiseError;
	                    });
	                }
	                catch (error) {
	                    handleUnhandledRejection(error);
	                }
	            }
	        };
	        const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');
	        function handleUnhandledRejection(e) {
	            api.onUnhandledError(e);
	            try {
	                const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];
	                if (typeof handler === 'function') {
	                    handler.call(this, e);
	                }
	            }
	            catch (err) { }
	        }
	        function isThenable(value) {
	            return value && value.then;
	        }
	        function forwardResolution(value) {
	            return value;
	        }
	        function forwardRejection(rejection) {
	            return ZoneAwarePromise.reject(rejection);
	        }
	        const symbolState = __symbol__('state');
	        const symbolValue = __symbol__('value');
	        const symbolFinally = __symbol__('finally');
	        const symbolParentPromiseValue = __symbol__('parentPromiseValue');
	        const symbolParentPromiseState = __symbol__('parentPromiseState');
	        const source = 'Promise.then';
	        const UNRESOLVED = null;
	        const RESOLVED = true;
	        const REJECTED = false;
	        const REJECTED_NO_CATCH = 0;
	        function makeResolver(promise, state) {
	            return (v) => {
	                try {
	                    resolvePromise(promise, state, v);
	                }
	                catch (err) {
	                    resolvePromise(promise, false, err);
	                }
	                // Do not return value or you will break the Promise spec.
	            };
	        }
	        const once = function () {
	            let wasCalled = false;
	            return function wrapper(wrappedFunction) {
	                return function () {
	                    if (wasCalled) {
	                        return;
	                    }
	                    wasCalled = true;
	                    wrappedFunction.apply(null, arguments);
	                };
	            };
	        };
	        const TYPE_ERROR = 'Promise resolved with itself';
	        const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace');
	        // Promise Resolution
	        function resolvePromise(promise, state, value) {
	            const onceWrapper = once();
	            if (promise === value) {
	                throw new TypeError(TYPE_ERROR);
	            }
	            if (promise[symbolState] === UNRESOLVED) {
	                // should only get value.then once based on promise spec.
	                let then = null;
	                try {
	                    if (typeof value === 'object' || typeof value === 'function') {
	                        then = value && value.then;
	                    }
	                }
	                catch (err) {
	                    onceWrapper(() => {
	                        resolvePromise(promise, false, err);
	                    })();
	                    return promise;
	                }
	                // if (value instanceof ZoneAwarePromise) {
	                if (state !== REJECTED &&
	                    value instanceof ZoneAwarePromise &&
	                    value.hasOwnProperty(symbolState) &&
	                    value.hasOwnProperty(symbolValue) &&
	                    value[symbolState] !== UNRESOLVED) {
	                    clearRejectedNoCatch(value);
	                    resolvePromise(promise, value[symbolState], value[symbolValue]);
	                }
	                else if (state !== REJECTED && typeof then === 'function') {
	                    try {
	                        then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
	                    }
	                    catch (err) {
	                        onceWrapper(() => {
	                            resolvePromise(promise, false, err);
	                        })();
	                    }
	                }
	                else {
	                    promise[symbolState] = state;
	                    const queue = promise[symbolValue];
	                    promise[symbolValue] = value;
	                    if (promise[symbolFinally] === symbolFinally) {
	                        // the promise is generated by Promise.prototype.finally
	                        if (state === RESOLVED) {
	                            // the state is resolved, should ignore the value
	                            // and use parent promise value
	                            promise[symbolState] = promise[symbolParentPromiseState];
	                            promise[symbolValue] = promise[symbolParentPromiseValue];
	                        }
	                    }
	                    // record task information in value when error occurs, so we can
	                    // do some additional work such as render longStackTrace
	                    if (state === REJECTED && value instanceof Error) {
	                        // check if longStackTraceZone is here
	                        const trace = Zone.currentTask &&
	                            Zone.currentTask.data &&
	                            Zone.currentTask.data[creationTrace];
	                        if (trace) {
	                            // only keep the long stack trace into error when in longStackTraceZone
	                            ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {
	                                configurable: true,
	                                enumerable: false,
	                                writable: true,
	                                value: trace,
	                            });
	                        }
	                    }
	                    for (let i = 0; i < queue.length;) {
	                        scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
	                    }
	                    if (queue.length == 0 && state == REJECTED) {
	                        promise[symbolState] = REJECTED_NO_CATCH;
	                        let uncaughtPromiseError = value;
	                        try {
	                            // Here we throws a new Error to print more readable error log
	                            // and if the value is not an error, zone.js builds an `Error`
	                            // Object here to attach the stack information.
	                            throw new Error('Uncaught (in promise): ' +
	                                readableObjectToString(value) +
	                                (value && value.stack ? '\n' + value.stack : ''));
	                        }
	                        catch (err) {
	                            uncaughtPromiseError = err;
	                        }
	                        if (isDisableWrappingUncaughtPromiseRejection) {
	                            // If disable wrapping uncaught promise reject
	                            // use the value instead of wrapping it.
	                            uncaughtPromiseError.throwOriginal = true;
	                        }
	                        uncaughtPromiseError.rejection = value;
	                        uncaughtPromiseError.promise = promise;
	                        uncaughtPromiseError.zone = Zone.current;
	                        uncaughtPromiseError.task = Zone.currentTask;
	                        _uncaughtPromiseErrors.push(uncaughtPromiseError);
	                        api.scheduleMicroTask(); // to make sure that it is running
	                    }
	                }
	            }
	            // Resolving an already resolved promise is a noop.
	            return promise;
	        }
	        const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');
	        function clearRejectedNoCatch(promise) {
	            if (promise[symbolState] === REJECTED_NO_CATCH) {
	                // if the promise is rejected no catch status
	                // and queue.length > 0, means there is a error handler
	                // here to handle the rejected promise, we should trigger
	                // windows.rejectionhandled eventHandler or nodejs rejectionHandled
	                // eventHandler
	                try {
	                    const handler = Zone[REJECTION_HANDLED_HANDLER];
	                    if (handler && typeof handler === 'function') {
	                        handler.call(this, { rejection: promise[symbolValue], promise: promise });
	                    }
	                }
	                catch (err) { }
	                promise[symbolState] = REJECTED;
	                for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
	                    if (promise === _uncaughtPromiseErrors[i].promise) {
	                        _uncaughtPromiseErrors.splice(i, 1);
	                    }
	                }
	            }
	        }
	        function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
	            clearRejectedNoCatch(promise);
	            const promiseState = promise[symbolState];
	            const delegate = promiseState
	                ? typeof onFulfilled === 'function'
	                    ? onFulfilled
	                    : forwardResolution
	                : typeof onRejected === 'function'
	                    ? onRejected
	                    : forwardRejection;
	            zone.scheduleMicroTask(source, () => {
	                try {
	                    const parentPromiseValue = promise[symbolValue];
	                    const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];
	                    if (isFinallyPromise) {
	                        // if the promise is generated from finally call, keep parent promise's state and value
	                        chainPromise[symbolParentPromiseValue] = parentPromiseValue;
	                        chainPromise[symbolParentPromiseState] = promiseState;
	                    }
	                    // should not pass value to finally callback
	                    const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution
	                        ? []
	                        : [parentPromiseValue]);
	                    resolvePromise(chainPromise, true, value);
	                }
	                catch (error) {
	                    // if error occurs, should always return this error
	                    resolvePromise(chainPromise, false, error);
	                }
	            }, chainPromise);
	        }
	        const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';
	        const noop = function () { };
	        const AggregateError = global.AggregateError;
	        class ZoneAwarePromise {
	            static toString() {
	                return ZONE_AWARE_PROMISE_TO_STRING;
	            }
	            static resolve(value) {
	                if (value instanceof ZoneAwarePromise) {
	                    return value;
	                }
	                return resolvePromise(new this(null), RESOLVED, value);
	            }
	            static reject(error) {
	                return resolvePromise(new this(null), REJECTED, error);
	            }
	            static withResolvers() {
	                const result = {};
	                result.promise = new ZoneAwarePromise((res, rej) => {
	                    result.resolve = res;
	                    result.reject = rej;
	                });
	                return result;
	            }
	            static any(values) {
	                if (!values || typeof values[Symbol.iterator] !== 'function') {
	                    return Promise.reject(new AggregateError([], 'All promises were rejected'));
	                }
	                const promises = [];
	                let count = 0;
	                try {
	                    for (let v of values) {
	                        count++;
	                        promises.push(ZoneAwarePromise.resolve(v));
	                    }
	                }
	                catch (err) {
	                    return Promise.reject(new AggregateError([], 'All promises were rejected'));
	                }
	                if (count === 0) {
	                    return Promise.reject(new AggregateError([], 'All promises were rejected'));
	                }
	                let finished = false;
	                const errors = [];
	                return new ZoneAwarePromise((resolve, reject) => {
	                    for (let i = 0; i < promises.length; i++) {
	                        promises[i].then((v) => {
	                            if (finished) {
	                                return;
	                            }
	                            finished = true;
	                            resolve(v);
	                        }, (err) => {
	                            errors.push(err);
	                            count--;
	                            if (count === 0) {
	                                finished = true;
	                                reject(new AggregateError(errors, 'All promises were rejected'));
	                            }
	                        });
	                    }
	                });
	            }
	            static race(values) {
	                let resolve;
	                let reject;
	                let promise = new this((res, rej) => {
	                    resolve = res;
	                    reject = rej;
	                });
	                function onResolve(value) {
	                    resolve(value);
	                }
	                function onReject(error) {
	                    reject(error);
	                }
	                for (let value of values) {
	                    if (!isThenable(value)) {
	                        value = this.resolve(value);
	                    }
	                    value.then(onResolve, onReject);
	                }
	                return promise;
	            }
	            static all(values) {
	                return ZoneAwarePromise.allWithCallback(values);
	            }
	            static allSettled(values) {
	                const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
	                return P.allWithCallback(values, {
	                    thenCallback: (value) => ({ status: 'fulfilled', value }),
	                    errorCallback: (err) => ({ status: 'rejected', reason: err }),
	                });
	            }
	            static allWithCallback(values, callback) {
	                let resolve;
	                let reject;
	                let promise = new this((res, rej) => {
	                    resolve = res;
	                    reject = rej;
	                });
	                // Start at 2 to prevent prematurely resolving if .then is called immediately.
	                let unresolvedCount = 2;
	                let valueIndex = 0;
	                const resolvedValues = [];
	                for (let value of values) {
	                    if (!isThenable(value)) {
	                        value = this.resolve(value);
	                    }
	                    const curValueIndex = valueIndex;
	                    try {
	                        value.then((value) => {
	                            resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;
	                            unresolvedCount--;
	                            if (unresolvedCount === 0) {
	                                resolve(resolvedValues);
	                            }
	                        }, (err) => {
	                            if (!callback) {
	                                reject(err);
	                            }
	                            else {
	                                resolvedValues[curValueIndex] = callback.errorCallback(err);
	                                unresolvedCount--;
	                                if (unresolvedCount === 0) {
	                                    resolve(resolvedValues);
	                                }
	                            }
	                        });
	                    }
	                    catch (thenErr) {
	                        reject(thenErr);
	                    }
	                    unresolvedCount++;
	                    valueIndex++;
	                }
	                // Make the unresolvedCount zero-based again.
	                unresolvedCount -= 2;
	                if (unresolvedCount === 0) {
	                    resolve(resolvedValues);
	                }
	                return promise;
	            }
	            constructor(executor) {
	                const promise = this;
	                if (!(promise instanceof ZoneAwarePromise)) {
	                    throw new Error('Must be an instanceof Promise.');
	                }
	                promise[symbolState] = UNRESOLVED;
	                promise[symbolValue] = []; // queue;
	                try {
	                    const onceWrapper = once();
	                    executor &&
	                        executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));
	                }
	                catch (error) {
	                    resolvePromise(promise, false, error);
	                }
	            }
	            get [Symbol.toStringTag]() {
	                return 'Promise';
	            }
	            get [Symbol.species]() {
	                return ZoneAwarePromise;
	            }
	            then(onFulfilled, onRejected) {
	                // We must read `Symbol.species` safely because `this` may be anything. For instance, `this`
	                // may be an object without a prototype (created through `Object.create(null)`); thus
	                // `this.constructor` will be undefined. One of the use cases is SystemJS creating
	                // prototype-less objects (modules) via `Object.create(null)`. The SystemJS creates an empty
	                // object and copies promise properties into that object (within the `getOrCreateLoad`
	                // function). The zone.js then checks if the resolved value has the `then` method and
	                // invokes it with the `value` context. Otherwise, this will throw an error: `TypeError:
	                // Cannot read properties of undefined (reading 'Symbol(Symbol.species)')`.
	                let C = this.constructor?.[Symbol.species];
	                if (!C || typeof C !== 'function') {
	                    C = this.constructor || ZoneAwarePromise;
	                }
	                const chainPromise = new C(noop);
	                const zone = Zone.current;
	                if (this[symbolState] == UNRESOLVED) {
	                    this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
	                }
	                else {
	                    scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
	                }
	                return chainPromise;
	            }
	            catch(onRejected) {
	                return this.then(null, onRejected);
	            }
	            finally(onFinally) {
	                // See comment on the call to `then` about why thee `Symbol.species` is safely accessed.
	                let C = this.constructor?.[Symbol.species];
	                if (!C || typeof C !== 'function') {
	                    C = ZoneAwarePromise;
	                }
	                const chainPromise = new C(noop);
	                chainPromise[symbolFinally] = symbolFinally;
	                const zone = Zone.current;
	                if (this[symbolState] == UNRESOLVED) {
	                    this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
	                }
	                else {
	                    scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
	                }
	                return chainPromise;
	            }
	        }
	        // Protect against aggressive optimizers dropping seemingly unused properties.
	        // E.g. Closure Compiler in advanced mode.
	        ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
	        ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
	        ZoneAwarePromise['race'] = ZoneAwarePromise.race;
	        ZoneAwarePromise['all'] = ZoneAwarePromise.all;
	        const NativePromise = (global[symbolPromise] = global['Promise']);
	        global['Promise'] = ZoneAwarePromise;
	        const symbolThenPatched = __symbol__('thenPatched');
	        function patchThen(Ctor) {
	            const proto = Ctor.prototype;
	            const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');
	            if (prop && (prop.writable === false || !prop.configurable)) {
	                // check Ctor.prototype.then propertyDescriptor is writable or not
	                // in meteor env, writable is false, we should ignore such case
	                return;
	            }
	            const originalThen = proto.then;
	            // Keep a reference to the original method.
	            proto[symbolThen] = originalThen;
	            Ctor.prototype.then = function (onResolve, onReject) {
	                const wrapped = new ZoneAwarePromise((resolve, reject) => {
	                    originalThen.call(this, resolve, reject);
	                });
	                return wrapped.then(onResolve, onReject);
	            };
	            Ctor[symbolThenPatched] = true;
	        }
	        api.patchThen = patchThen;
	        function zoneify(fn) {
	            return function (self, args) {
	                let resultPromise = fn.apply(self, args);
	                if (resultPromise instanceof ZoneAwarePromise) {
	                    return resultPromise;
	                }
	                let ctor = resultPromise.constructor;
	                if (!ctor[symbolThenPatched]) {
	                    patchThen(ctor);
	                }
	                return resultPromise;
	            };
	        }
	        if (NativePromise) {
	            patchThen(NativePromise);
	            patchMethod(global, 'fetch', (delegate) => zoneify(delegate));
	        }
	        // This is not part of public API, but it is useful for tests, so we expose it.
	        Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
	        return ZoneAwarePromise;
	    });
	}

	function patchToString(Zone) {
	    // override Function.prototype.toString to make zone.js patched function
	    // look like native function
	    Zone.__load_patch('toString', (global) => {
	        // patch Func.prototype.toString to let them look like native
	        const originalFunctionToString = Function.prototype.toString;
	        const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
	        const PROMISE_SYMBOL = zoneSymbol('Promise');
	        const ERROR_SYMBOL = zoneSymbol('Error');
	        const newFunctionToString = function toString() {
	            if (typeof this === 'function') {
	                const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];
	                if (originalDelegate) {
	                    if (typeof originalDelegate === 'function') {
	                        return originalFunctionToString.call(originalDelegate);
	                    }
	                    else {
	                        return Object.prototype.toString.call(originalDelegate);
	                    }
	                }
	                if (this === Promise) {
	                    const nativePromise = global[PROMISE_SYMBOL];
	                    if (nativePromise) {
	                        return originalFunctionToString.call(nativePromise);
	                    }
	                }
	                if (this === Error) {
	                    const nativeError = global[ERROR_SYMBOL];
	                    if (nativeError) {
	                        return originalFunctionToString.call(nativeError);
	                    }
	                }
	            }
	            return originalFunctionToString.call(this);
	        };
	        newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
	        Function.prototype.toString = newFunctionToString;
	        // patch Object.prototype.toString to let them look like native
	        const originalObjectToString = Object.prototype.toString;
	        const PROMISE_OBJECT_TO_STRING = '[object Promise]';
	        Object.prototype.toString = function () {
	            if (typeof Promise === 'function' && this instanceof Promise) {
	                return PROMISE_OBJECT_TO_STRING;
	            }
	            return originalObjectToString.call(this);
	        };
	    });
	}

	function patchCallbacks(api, target, targetName, method, callbacks) {
	    const symbol = Zone.__symbol__(method);
	    if (target[symbol]) {
	        return;
	    }
	    const nativeDelegate = (target[symbol] = target[method]);
	    target[method] = function (name, opts, options) {
	        if (opts && opts.prototype) {
	            callbacks.forEach(function (callback) {
	                const source = `${targetName}.${method}::` + callback;
	                const prototype = opts.prototype;
	                // Note: the `patchCallbacks` is used for patching the `document.registerElement` and
	                // `customElements.define`. We explicitly wrap the patching code into try-catch since
	                // callbacks may be already patched by other web components frameworks (e.g. LWC), and they
	                // make those properties non-writable. This means that patching callback will throw an error
	                // `cannot assign to read-only property`. See this code as an example:
	                // https://github.com/salesforce/lwc/blob/master/packages/@lwc/engine-core/src/framework/base-bridge-element.ts#L180-L186
	                // We don't want to stop the application rendering if we couldn't patch some
	                // callback, e.g. `attributeChangedCallback`.
	                try {
	                    if (prototype.hasOwnProperty(callback)) {
	                        const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);
	                        if (descriptor && descriptor.value) {
	                            descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);
	                            api._redefineProperty(opts.prototype, callback, descriptor);
	                        }
	                        else if (prototype[callback]) {
	                            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
	                        }
	                    }
	                    else if (prototype[callback]) {
	                        prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
	                    }
	                }
	                catch {
	                    // Note: we leave the catch block empty since there's no way to handle the error related
	                    // to non-writable property.
	                }
	            });
	        }
	        return nativeDelegate.call(target, name, opts, options);
	    };
	    api.attachOriginToPatched(target[method], nativeDelegate);
	}

	function patchUtil(Zone) {
	    Zone.__load_patch('util', (global, Zone, api) => {
	        // Collect native event names by looking at properties
	        // on the global namespace, e.g. 'onclick'.
	        const eventNames = getOnEventNames(global);
	        api.patchOnProperties = patchOnProperties;
	        api.patchMethod = patchMethod;
	        api.bindArguments = bindArguments;
	        api.patchMacroTask = patchMacroTask;
	        // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS`
	        // to define which events will not be patched by `Zone.js`. In newer version (>=0.9.0), we
	        // change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep the name consistent with
	        // angular repo. The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be
	        // supported for backwards compatibility.
	        const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');
	        const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');
	        if (global[SYMBOL_UNPATCHED_EVENTS]) {
	            global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
	        }
	        if (global[SYMBOL_BLACK_LISTED_EVENTS]) {
	            Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] =
	                global[SYMBOL_BLACK_LISTED_EVENTS];
	        }
	        api.patchEventPrototype = patchEventPrototype;
	        api.patchEventTarget = patchEventTarget;
	        api.isIEOrEdge = isIEOrEdge;
	        api.ObjectDefineProperty = ObjectDefineProperty;
	        api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
	        api.ObjectCreate = ObjectCreate;
	        api.ArraySlice = ArraySlice;
	        api.patchClass = patchClass;
	        api.wrapWithCurrentZone = wrapWithCurrentZone;
	        api.filterProperties = filterProperties;
	        api.attachOriginToPatched = attachOriginToPatched;
	        api._redefineProperty = Object.defineProperty;
	        api.patchCallbacks = patchCallbacks;
	        api.getGlobalObjects = () => ({
	            globalSources,
	            zoneSymbolEventNames,
	            eventNames,
	            isBrowser,
	            isMix,
	            isNode,
	            TRUE_STR,
	            FALSE_STR,
	            ZONE_SYMBOL_PREFIX,
	            ADD_EVENT_LISTENER_STR,
	            REMOVE_EVENT_LISTENER_STR,
	        });
	    });
	}

	function patchCommon(Zone) {
	    patchPromise(Zone);
	    patchToString(Zone);
	    patchUtil(Zone);
	}

	const Zone$1 = loadZone();
	patchCommon(Zone$1);
	patchBrowser(Zone$1);
	return zone;
}

requireZone();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopLogger {
    emit(_logRecord) { }
}
const NOOP_LOGGER = new NoopLogger();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoopLoggerProvider {
    getLogger(_name, _version, _options) {
        return new NoopLogger();
    }
}
const NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProxyLogger {
    constructor(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    /**
     * Emit a log record. This method should only be used by log appenders.
     *
     * @param logRecord
     */
    emit(logRecord) {
        this._getLogger().emit(logRecord);
    }
    /**
     * Try to get a logger from the proxy logger provider.
     * If the proxy logger provider has no delegate, return a noop logger.
     */
    _getLogger() {
        if (this._delegate) {
            return this._delegate;
        }
        const logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
        if (!logger) {
            return NOOP_LOGGER;
        }
        this._delegate = logger;
        return this._delegate;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProxyLoggerProvider {
    getLogger(name, version, options) {
        var _a;
        return ((_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger(this, name, version, options));
    }
    getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_LOGGER_PROVIDER;
    }
    /**
     * Set the delegate logger provider
     */
    setDelegate(delegate) {
        this._delegate = delegate;
    }
    getDelegateLogger(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api and
// @opentelemetry/core too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
const _globalThis$2 = typeof globalThis === 'object'
    ? globalThis
    : typeof self === 'object'
        ? self
        : typeof window === 'object'
            ? window
            : typeof global === 'object'
                ? global
                : {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GLOBAL_LOGS_API_KEY = Symbol.for('io.opentelemetry.js.api.logs');
const _global = _globalThis$2;
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */
function makeGetter(requiredVersion, instance, fallback) {
    return (version) => version === requiredVersion ? instance : fallback;
}
/**
 * A number which should be incremented each time a backwards incompatible
 * change is made to the API. This number is used when an API package
 * attempts to access the global API to ensure it is getting a compatible
 * version. If the global API is not compatible with the API package
 * attempting to get it, a NOOP API implementation will be returned.
 */
const API_BACKWARDS_COMPATIBILITY_VERSION = 1;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogsAPI {
    constructor() {
        this._proxyLoggerProvider = new ProxyLoggerProvider();
    }
    static getInstance() {
        if (!this._instance) {
            this._instance = new LogsAPI();
        }
        return this._instance;
    }
    setGlobalLoggerProvider(provider) {
        if (_global[GLOBAL_LOGS_API_KEY]) {
            return this.getLoggerProvider();
        }
        _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
        this._proxyLoggerProvider.setDelegate(provider);
        return provider;
    }
    /**
     * Returns the global logger provider.
     *
     * @returns LoggerProvider
     */
    getLoggerProvider() {
        var _a, _b;
        return ((_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider);
    }
    /**
     * Returns a logger from the global logger provider.
     *
     * @returns Logger
     */
    getLogger(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
    }
    /** Remove the global logger provider */
    disable() {
        delete _global[GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new ProxyLoggerProvider();
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logs = LogsAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Enable instrumentations
 * @param instrumentations
 * @param tracerProvider
 * @param meterProvider
 */
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
    for (let i = 0, j = instrumentations.length; i < j; i++) {
        const instrumentation = instrumentations[i];
        if (tracerProvider) {
            instrumentation.setTracerProvider(tracerProvider);
        }
        if (meterProvider) {
            instrumentation.setMeterProvider(meterProvider);
        }
        if (loggerProvider && instrumentation.setLoggerProvider) {
            instrumentation.setLoggerProvider(loggerProvider);
        }
        // instrumentations have been already enabled during creation
        // so enable only if user prevented that by setting enabled to false
        // this is to prevent double enabling but when calling register all
        // instrumentations should be now enabled
        if (!instrumentation.getConfig().enabled) {
            instrumentation.enable();
        }
    }
}
/**
 * Disable instrumentations
 * @param instrumentations
 */
function disableInstrumentations(instrumentations) {
    instrumentations.forEach(instrumentation => instrumentation.disable());
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * It will register instrumentations and plugins
 * @param options
 * @return returns function to unload instrumentation and plugins that were
 *   registered
 */
function registerInstrumentations(options) {
    const tracerProvider = options.tracerProvider || trace.getTracerProvider();
    const meterProvider = options.meterProvider || metrics.getMeterProvider();
    const loggerProvider = options.loggerProvider || logs.getLoggerProvider();
    const instrumentations = options.instrumentations?.flat() ?? [];
    enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
    return () => {
        disableInstrumentations(instrumentations);
    };
}

var shimmer_1;
var hasRequiredShimmer;

function requireShimmer () {
	if (hasRequiredShimmer) return shimmer_1;
	hasRequiredShimmer = 1;

	function isFunction (funktion) {
	  return typeof funktion === 'function'
	}

	// Default to complaining loudly when things don't go according to plan.
	var logger = console.error.bind(console);

	// Sets a property on an object, preserving its enumerability.
	// This function assumes that the property is already writable.
	function defineProperty (obj, name, value) {
	  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
	  Object.defineProperty(obj, name, {
	    configurable: true,
	    enumerable: enumerable,
	    writable: true,
	    value: value
	  });
	}

	// Keep initialization idempotent.
	function shimmer (options) {
	  if (options && options.logger) {
	    if (!isFunction(options.logger)) logger("new logger isn't a function, not replacing");
	    else logger = options.logger;
	  }
	}

	function wrap (nodule, name, wrapper) {
	  if (!nodule || !nodule[name]) {
	    logger('no original function ' + name + ' to wrap');
	    return
	  }

	  if (!wrapper) {
	    logger('no wrapper function');
	    logger((new Error()).stack);
	    return
	  }

	  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
	    logger('original object and wrapper must be functions');
	    return
	  }

	  var original = nodule[name];
	  var wrapped = wrapper(original, name);

	  defineProperty(wrapped, '__original', original);
	  defineProperty(wrapped, '__unwrap', function () {
	    if (nodule[name] === wrapped) defineProperty(nodule, name, original);
	  });
	  defineProperty(wrapped, '__wrapped', true);

	  defineProperty(nodule, name, wrapped);
	  return wrapped
	}

	function massWrap (nodules, names, wrapper) {
	  if (!nodules) {
	    logger('must provide one or more modules to patch');
	    logger((new Error()).stack);
	    return
	  } else if (!Array.isArray(nodules)) {
	    nodules = [nodules];
	  }

	  if (!(names && Array.isArray(names))) {
	    logger('must provide one or more functions to wrap on modules');
	    return
	  }

	  nodules.forEach(function (nodule) {
	    names.forEach(function (name) {
	      wrap(nodule, name, wrapper);
	    });
	  });
	}

	function unwrap (nodule, name) {
	  if (!nodule || !nodule[name]) {
	    logger('no function to unwrap.');
	    logger((new Error()).stack);
	    return
	  }

	  if (!nodule[name].__unwrap) {
	    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');
	  } else {
	    return nodule[name].__unwrap()
	  }
	}

	function massUnwrap (nodules, names) {
	  if (!nodules) {
	    logger('must provide one or more modules to patch');
	    logger((new Error()).stack);
	    return
	  } else if (!Array.isArray(nodules)) {
	    nodules = [nodules];
	  }

	  if (!(names && Array.isArray(names))) {
	    logger('must provide one or more functions to unwrap on modules');
	    return
	  }

	  nodules.forEach(function (nodule) {
	    names.forEach(function (name) {
	      unwrap(nodule, name);
	    });
	  });
	}

	shimmer.wrap = wrap;
	shimmer.massWrap = massWrap;
	shimmer.unwrap = unwrap;
	shimmer.massUnwrap = massUnwrap;

	shimmer_1 = shimmer;
	return shimmer_1;
}

var shimmerExports = requireShimmer();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base abstract internal class for instrumenting node and web plugins
 */
class InstrumentationAbstract {
    instrumentationName;
    instrumentationVersion;
    _config = {};
    _tracer;
    _meter;
    _logger;
    _diag;
    constructor(instrumentationName, instrumentationVersion, config) {
        this.instrumentationName = instrumentationName;
        this.instrumentationVersion = instrumentationVersion;
        this.setConfig(config);
        this._diag = diag.createComponentLogger({
            namespace: instrumentationName,
        });
        this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
        this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
        this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
        this._updateMetricInstruments();
    }
    /* Api to wrap instrumented method */
    _wrap = shimmerExports.wrap;
    /* Api to unwrap instrumented methods */
    _unwrap = shimmerExports.unwrap;
    /* Api to mass wrap instrumented method */
    _massWrap = shimmerExports.massWrap;
    /* Api to mass unwrap instrumented methods */
    _massUnwrap = shimmerExports.massUnwrap;
    /* Returns meter */
    get meter() {
        return this._meter;
    }
    /**
     * Sets MeterProvider to this plugin
     * @param meterProvider
     */
    setMeterProvider(meterProvider) {
        this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
        this._updateMetricInstruments();
    }
    /* Returns logger */
    get logger() {
        return this._logger;
    }
    /**
     * Sets LoggerProvider to this plugin
     * @param loggerProvider
     */
    setLoggerProvider(loggerProvider) {
        this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
    }
    /**
     * @experimental
     *
     * Get module definitions defined by {@link init}.
     * This can be used for experimental compile-time instrumentation.
     *
     * @returns an array of {@link InstrumentationModuleDefinition}
     */
    getModuleDefinitions() {
        const initResult = this.init() ?? [];
        if (!Array.isArray(initResult)) {
            return [initResult];
        }
        return initResult;
    }
    /**
     * Sets the new metric instruments with the current Meter.
     */
    _updateMetricInstruments() {
        return;
    }
    /* Returns InstrumentationConfig */
    getConfig() {
        return this._config;
    }
    /**
     * Sets InstrumentationConfig to this plugin
     * @param config
     */
    setConfig(config) {
        // copy config first level properties to ensure they are immutable.
        // nested properties are not copied, thus are mutable from the outside.
        this._config = {
            enabled: true,
            ...config,
        };
    }
    /**
     * Sets TraceProvider to this plugin
     * @param tracerProvider
     */
    setTracerProvider(tracerProvider) {
        this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
    }
    /* Returns tracer */
    get tracer() {
        return this._tracer;
    }
    /**
     * Execute span customization hook, if configured, and log any errors.
     * Any semantics of the trigger and info are defined by the specific instrumentation.
     * @param hookHandler The optional hook handler which the user has configured via instrumentation config
     * @param triggerName The name of the trigger for executing the hook for logging purposes
     * @param span The span to which the hook should be applied
     * @param info The info object to be passed to the hook, with useful data the hook may use
     */
    _runSpanCustomizationHook(hookHandler, triggerName, span, info) {
        if (!hookHandler) {
            return;
        }
        try {
            hookHandler(span, info);
        }
        catch (e) {
            this._diag.error(`Error running span customization hook due to exception in handler`, { triggerName }, e);
        }
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base abstract class for instrumenting web plugins
 */
class InstrumentationBase extends InstrumentationAbstract {
    constructor(instrumentationName, instrumentationVersion, config) {
        super(instrumentationName, instrumentationVersion, config);
        if (this._config.enabled) {
            this.enable();
        }
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * function to execute patched function and being able to catch errors
 * @param execute - function to be executed
 * @param onFinish - callback to run when execute finishes
 */
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
    let error;
    let result;
    try {
        result = execute();
    }
    catch (e) {
        error = e;
    }
    finally {
        onFinish(error, result);
        // eslint-disable-next-line no-unsafe-finally
        return result;
    }
}
/**
 * Checks if certain function has been already wrapped
 * @param func
 */
function isWrapped(func) {
    return (typeof func === 'function' &&
        typeof func.__original === 'function' &&
        typeof func.__unwrap === 'function' &&
        func.__wrapped === true);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SemconvStability;
(function (SemconvStability) {
    /** Emit only stable semantic conventions. */
    SemconvStability[SemconvStability["STABLE"] = 1] = "STABLE";
    /** Emit only old semantic conventions. */
    SemconvStability[SemconvStability["OLD"] = 2] = "OLD";
    /** Emit both stable and old semantic conventions. */
    SemconvStability[SemconvStability["DUPLICATE"] = 3] = "DUPLICATE";
})(SemconvStability || (SemconvStability = {}));
/**
 * Determine the appropriate semconv stability for the given namespace.
 *
 * This will parse the given string of comma-separated values (often
 * `process.env.OTEL_SEMCONV_STABILITY_OPT_IN`) looking for the `${namespace}`
 * or `${namespace}/dup` tokens. This is a pattern defined by a number of
 * non-normative semconv documents.
 *
 * For example:
 * - namespace 'http': https://opentelemetry.io/docs/specs/semconv/non-normative/http-migration/
 * - namespace 'database': https://opentelemetry.io/docs/specs/semconv/non-normative/database-migration/
 * - namespace 'k8s': https://opentelemetry.io/docs/specs/semconv/non-normative/k8s-migration/
 *
 * Usage:
 *
 *  import {SemconvStability, semconvStabilityFromStr} from '@opentelemetry/instrumentation';
 *
 *  export class FooInstrumentation extends InstrumentationBase<FooInstrumentationConfig> {
 *    private _semconvStability: SemconvStability;
 *    constructor(config: FooInstrumentationConfig = {}) {
 *      super('@opentelemetry/instrumentation-foo', VERSION, config);
 *
 *      // When supporting the OTEL_SEMCONV_STABILITY_OPT_IN envvar
 *      this._semconvStability = semconvStabilityFromStr(
 *        'http',
 *        process.env.OTEL_SEMCONV_STABILITY_OPT_IN
 *      );
 *
 *      // or when supporting a `semconvStabilityOptIn` config option (e.g. for
 *      // the web where there are no envvars).
 *      this._semconvStability = semconvStabilityFromStr(
 *        'http',
 *        config?.semconvStabilityOptIn
 *      );
 *    }
 *  }
 *
 *  // Then, to apply semconv, use the following or similar:
 *  if (this._semconvStability & SemconvStability.OLD) {
 *    // ...
 *  }
 *  if (this._semconvStability & SemconvStability.STABLE) {
 *    // ...
 *  }
 *
 */
function semconvStabilityFromStr(namespace, str) {
    let semconvStability = SemconvStability.OLD;
    // The same parsing of `str` as `getStringListFromEnv` from the core pkg.
    const entries = str
        ?.split(',')
        .map(v => v.trim())
        .filter(s => s !== '');
    for (const entry of entries ?? []) {
        if (entry.toLowerCase() === namespace + '/dup') {
            // DUPLICATE takes highest precedence.
            semconvStability = SemconvStability.DUPLICATE;
            break;
        }
        else if (entry.toLowerCase() === namespace) {
            semconvStability = SemconvStability.STABLE;
        }
    }
    return semconvStability;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';

(undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function parsePairKeyValue(entry) {
    var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
        return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
var _globalThis$1 = typeof globalThis === 'object'
    ? globalThis
    : typeof self === 'object'
        ? self
        : typeof window === 'object'
            ? window
            : typeof global === 'object'
                ? global
                : {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var ENVIRONMENT_BOOLEAN_KEYS = ['OTEL_SDK_DISABLED'];
function isEnvVarABoolean(key) {
    return (ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1);
}
var ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_BLRP_EXPORT_TIMEOUT',
    'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BLRP_MAX_QUEUE_SIZE',
    'OTEL_BLRP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function isEnvVarANumber(key) {
    return (ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
];
function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: '',
    OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_LOGS_EXPORTER: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
};
/**
 * @param key
 * @param environment
 * @param values
 */
function parseBoolean(key, environment, values) {
    if (typeof values[key] === 'undefined') {
        return;
    }
    var value = String(values[key]);
    // support case-insensitive "true"
    environment[key] = value.toLowerCase() === 'true';
}
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function parseNumber(name, environment, values, min, max) {
    if (min === void 0) { min = -Infinity; }
    if (max === void 0) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function parseStringList(name, output, input, separator) {
    if (separator === void 0) { separator = DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function parseEnvironment(values) {
    var environment = {};
    for (var env in DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (isEnvVarABoolean(key)) {
                    parseBoolean(key, environment, values);
                }
                else if (isEnvVarANumber(key)) {
                    parseNumber(key, environment, values);
                }
                else if (isEnvVarAList(key)) {
                    parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Gets the environment variables
 */
function getEnv() {
    var globalEnv = parseEnvironment(_globalThis$1);
    return Object.assign({}, DEFAULT_ENVIRONMENT, globalEnv);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hexToBase64(hexStr) {
    var hexStrLen = hexStr.length;
    var hexAsciiCharsStr = '';
    for (var i = 0; i < hexStrLen; i += 2) {
        var hexPair = hexStr.substring(i, i + 2);
        var hexVal = parseInt(hexPair, 16);
        hexAsciiCharsStr += String.fromCharCode(hexVal);
    }
    return btoa(hexAsciiCharsStr);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NANOSECOND_DIGITS$3 = 9;
var SECOND_TO_NANOSECONDS$3 = Math.pow(10, NANOSECOND_DIGITS$3);
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS$3 + time[1];
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$4 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray([this._that], __read$4(args), false))).then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$3 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var DEFAULT_TRACE_TIMEOUT = 10000;
var DEFAULT_EXPORT_MAX_ATTEMPTS = 5;
var DEFAULT_EXPORT_INITIAL_BACKOFF = 1000;
var DEFAULT_EXPORT_MAX_BACKOFF = 5000;
var DEFAULT_EXPORT_BACKOFF_MULTIPLIER = 1.5;
/**
 * Parses headers from config leaving only those that have defined values
 * @param partialHeaders
 */
function parseHeaders(partialHeaders) {
    if (partialHeaders === void 0) { partialHeaders = {}; }
    var headers = {};
    Object.entries(partialHeaders).forEach(function (_a) {
        var _b = __read$3(_a, 2), key = _b[0], value = _b[1];
        if (typeof value !== 'undefined') {
            headers[key] = String(value);
        }
        else {
            diag.warn("Header \"" + key + "\" has wrong value and will be ignored");
        }
    });
    return headers;
}
/**
 * Adds path (version + signal) to a no per-signal endpoint
 * @param url
 * @param path
 * @returns url + path
 */
function appendResourcePathToUrl(url, path) {
    if (!url.endsWith('/')) {
        url = url + '/';
    }
    return url + path;
}
/**
 * Adds root path to signal specific endpoint when endpoint contains no path part and no root path
 * @param url
 * @returns url
 */
function appendRootPathToUrlIfNeeded(url) {
    try {
        var parsedUrl = new URL(url);
        if (parsedUrl.pathname === '') {
            parsedUrl.pathname = parsedUrl.pathname + '/';
        }
        return parsedUrl.toString();
    }
    catch (_a) {
        diag.warn("Could not parse export URL: '" + url + "'");
        return url;
    }
}
/**
 * Configure exporter trace timeout value from passed in value or environment variables
 * @param timeoutMillis
 * @returns timeout value in milliseconds
 */
function configureExporterTimeout(timeoutMillis) {
    if (typeof timeoutMillis === 'number') {
        if (timeoutMillis <= 0) {
            // OTLP exporter configured timeout - using default value of 10000ms
            return invalidTimeout(timeoutMillis, DEFAULT_TRACE_TIMEOUT);
        }
        return timeoutMillis;
    }
    else {
        return getExporterTimeoutFromEnv();
    }
}
function getExporterTimeoutFromEnv() {
    var _a;
    var definedTimeout = Number((_a = getEnv().OTEL_EXPORTER_OTLP_TRACES_TIMEOUT) !== null && _a !== void 0 ? _a : getEnv().OTEL_EXPORTER_OTLP_TIMEOUT);
    if (definedTimeout <= 0) {
        // OTLP exporter configured timeout - using default value of 10000ms
        return invalidTimeout(definedTimeout, DEFAULT_TRACE_TIMEOUT);
    }
    else {
        return definedTimeout;
    }
}
// OTLP exporter configured timeout - using default value of 10000ms
function invalidTimeout(timeout, defaultTimeout) {
    diag.warn('Timeout must be greater than 0', timeout);
    return defaultTimeout;
}
function isExportRetryable(statusCode) {
    var retryCodes = [429, 502, 503, 504];
    return retryCodes.includes(statusCode);
}
function parseRetryAfterToMills(retryAfter) {
    if (retryAfter == null) {
        return -1;
    }
    var seconds = Number.parseInt(retryAfter, 10);
    if (Number.isInteger(seconds)) {
        return seconds > 0 ? seconds * 1000 : -1;
    }
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives
    var delay = new Date(retryAfter).getTime() - Date.now();
    if (delay >= 0) {
        return delay;
    }
    return 0;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Collector Exporter abstract base class
 */
var OTLPExporterBase = /** @class */ (function () {
    /**
     * @param config
     */
    function OTLPExporterBase(config) {
        if (config === void 0) { config = {}; }
        this._sendingPromises = [];
        this.url = this.getDefaultUrl(config);
        if (typeof config.hostname === 'string') {
            this.hostname = config.hostname;
        }
        this.shutdown = this.shutdown.bind(this);
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        this._concurrencyLimit =
            typeof config.concurrencyLimit === 'number'
                ? config.concurrencyLimit
                : Infinity;
        this.timeoutMillis = configureExporterTimeout(config.timeoutMillis);
        // platform dependent
        this.onInit(config);
    }
    /**
     * Export items.
     * @param items
     * @param resultCallback
     */
    OTLPExporterBase.prototype.export = function (items, resultCallback) {
        if (this._shutdownOnce.isCalled) {
            resultCallback({
                code: ExportResultCode.FAILED,
                error: new Error('Exporter has been shutdown'),
            });
            return;
        }
        if (this._sendingPromises.length >= this._concurrencyLimit) {
            resultCallback({
                code: ExportResultCode.FAILED,
                error: new Error('Concurrent export limit reached'),
            });
            return;
        }
        this._export(items)
            .then(function () {
            resultCallback({ code: ExportResultCode.SUCCESS });
        })
            .catch(function (error) {
            resultCallback({ code: ExportResultCode.FAILED, error: error });
        });
    };
    OTLPExporterBase.prototype._export = function (items) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                diag.debug('items to be sent', items);
                _this.send(items, resolve, reject);
            }
            catch (e) {
                reject(e);
            }
        });
    };
    /**
     * Shutdown the exporter.
     */
    OTLPExporterBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
    };
    /**
     * Exports any pending spans in the exporter
     */
    OTLPExporterBase.prototype.forceFlush = function () {
        return Promise.all(this._sendingPromises).then(function () {
            /** ignore resolved values */
        });
    };
    /**
     * Called by _shutdownOnce with BindOnceFuture
     */
    OTLPExporterBase.prototype._shutdown = function () {
        diag.debug('shutdown started');
        this.onShutdown();
        return this.forceFlush();
    };
    return OTLPExporterBase;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Interface for handling error
 */
var OTLPExporterError = /** @class */ (function (_super) {
    __extends$2(OTLPExporterError, _super);
    function OTLPExporterError(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = 'OTLPExporterError';
        _this.data = data;
        _this.code = code;
        return _this;
    }
    return OTLPExporterError;
}(Error));

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read$2 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * Send metrics/spans using browser navigator.sendBeacon
 * @param body
 * @param url
 * @param blobPropertyBag
 * @param onSuccess
 * @param onError
 */
function sendWithBeacon(body, url, blobPropertyBag, onSuccess, onError) {
    if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {
        diag.debug('sendBeacon - can send', body);
        onSuccess();
    }
    else {
        var error = new OTLPExporterError("sendBeacon - cannot send " + body);
        onError(error);
    }
}
/**
 * function to send metrics/spans using browser XMLHttpRequest
 *     used when navigator.sendBeacon is not available
 * @param body
 * @param url
 * @param headers
 * @param onSuccess
 * @param onError
 */
function sendWithXhr(body, url, headers, exporterTimeout, onSuccess, onError) {
    var retryTimer;
    var xhr;
    var reqIsDestroyed = false;
    var exporterTimer = setTimeout(function () {
        clearTimeout(retryTimer);
        reqIsDestroyed = true;
        if (xhr.readyState === XMLHttpRequest.DONE) {
            var err = new OTLPExporterError('Request Timeout');
            onError(err);
        }
        else {
            xhr.abort();
        }
    }, exporterTimeout);
    var sendWithRetry = function (retries, minDelay) {
        if (retries === void 0) { retries = DEFAULT_EXPORT_MAX_ATTEMPTS; }
        if (minDelay === void 0) { minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF; }
        xhr = new XMLHttpRequest();
        xhr.open('POST', url);
        var defaultHeaders = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        };
        Object.entries(__assign(__assign({}, defaultHeaders), headers)).forEach(function (_a) {
            var _b = __read$2(_a, 2), k = _b[0], v = _b[1];
            xhr.setRequestHeader(k, v);
        });
        xhr.send(body);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {
                if (xhr.status >= 200 && xhr.status <= 299) {
                    diag.debug('xhr success', body);
                    onSuccess();
                    clearTimeout(exporterTimer);
                    clearTimeout(retryTimer);
                }
                else if (xhr.status && isExportRetryable(xhr.status) && retries > 0) {
                    var retryTime = void 0;
                    minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;
                    // retry after interval specified in Retry-After header
                    if (xhr.getResponseHeader('Retry-After')) {
                        retryTime = parseRetryAfterToMills(xhr.getResponseHeader('Retry-After'));
                    }
                    else {
                        // exponential backoff with jitter
                        retryTime = Math.round(Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);
                    }
                    retryTimer = setTimeout(function () {
                        sendWithRetry(retries - 1, minDelay);
                    }, retryTime);
                }
                else {
                    var error = new OTLPExporterError("Failed to export with XHR (status: " + xhr.status + ")", xhr.status);
                    onError(error);
                    clearTimeout(exporterTimer);
                    clearTimeout(retryTimer);
                }
            }
        };
        xhr.onabort = function () {
            if (reqIsDestroyed) {
                var err = new OTLPExporterError('Request Timeout');
                onError(err);
            }
            clearTimeout(exporterTimer);
            clearTimeout(retryTimer);
        };
        xhr.onerror = function () {
            if (reqIsDestroyed) {
                var err = new OTLPExporterError('Request Timeout');
                onError(err);
            }
            clearTimeout(exporterTimer);
            clearTimeout(retryTimer);
        };
    };
    sendWithRetry();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Collector Metric Exporter abstract base class
 */
var OTLPExporterBrowserBase = /** @class */ (function (_super) {
    __extends$1(OTLPExporterBrowserBase, _super);
    /**
     * @param config
     */
    function OTLPExporterBrowserBase(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        _this._useXHR = false;
        _this._useXHR =
            !!config.headers || typeof navigator.sendBeacon !== 'function';
        if (_this._useXHR) {
            _this._headers = Object.assign({}, parseHeaders(config.headers), parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_HEADERS));
        }
        else {
            _this._headers = {};
        }
        return _this;
    }
    OTLPExporterBrowserBase.prototype.onInit = function () {
        _globalThis$1.addEventListener('unload', this.shutdown);
    };
    OTLPExporterBrowserBase.prototype.onShutdown = function () {
        _globalThis$1.removeEventListener('unload', this.shutdown);
    };
    OTLPExporterBrowserBase.prototype.send = function (items, onSuccess, onError) {
        var _this = this;
        if (this._shutdownOnce.isCalled) {
            diag.debug('Shutdown already started. Cannot send objects');
            return;
        }
        var serviceRequest = this.convert(items);
        var body = JSON.stringify(serviceRequest);
        var promise = new Promise(function (resolve, reject) {
            if (_this._useXHR) {
                sendWithXhr(body, _this.url, _this._headers, _this.timeoutMillis, resolve, reject);
            }
            else {
                sendWithBeacon(body, _this.url, { type: 'application/json' }, resolve, reject);
            }
        }).then(onSuccess, onError);
        this._sendingPromises.push(promise);
        var popPromise = function () {
            var index = _this._sendingPromises.indexOf(promise);
            _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
    };
    return OTLPExporterBrowserBase;
}(OTLPExporterBase));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NANOSECONDS = BigInt(1000000000);
function hrTimeToNanos(hrTime) {
    return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
}
function toLongBits(value) {
    var low = Number(BigInt.asUintN(32, value));
    var high = Number(BigInt.asUintN(32, value >> BigInt(32)));
    return { low: low, high: high };
}
function encodeAsLongBits(hrTime) {
    var nanos = hrTimeToNanos(hrTime);
    return toLongBits(nanos);
}
function encodeAsString(hrTime) {
    var nanos = hrTimeToNanos(hrTime);
    return nanos.toString();
}
var encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;
function identity(value) {
    return value;
}
function optionalHexToBase64(str) {
    if (str === undefined)
        return undefined;
    return hexToBase64(str);
}
var DEFAULT_ENCODER = {
    encodeHrTime: encodeAsLongBits,
    encodeSpanContext: hexToBase64,
    encodeOptionalSpanContext: optionalHexToBase64,
};
function getOtlpEncoder(options) {
    var _a, _b;
    if (options === undefined) {
        return DEFAULT_ENCODER;
    }
    var useLongBits = (_a = options.useLongBits) !== null && _a !== void 0 ? _a : true;
    var useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : false;
    return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity : hexToBase64,
        encodeOptionalSpanContext: useHex ? identity : optionalHexToBase64,
    };
}

var __read$1 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function toAttributes(attributes) {
    return Object.keys(attributes).map(function (key) { return toKeyValue(key, attributes[key]); });
}
function toKeyValue(key, value) {
    return {
        key: key,
        value: toAnyValue(value),
    };
}
function toAnyValue(value) {
    var t = typeof value;
    if (t === 'string')
        return { stringValue: value };
    if (t === 'number') {
        if (!Number.isInteger(value))
            return { doubleValue: value };
        return { intValue: value };
    }
    if (t === 'boolean')
        return { boolValue: value };
    if (value instanceof Uint8Array)
        return { bytesValue: value };
    if (Array.isArray(value))
        return { arrayValue: { values: value.map(toAnyValue) } };
    if (t === 'object' && value != null)
        return {
            kvlistValue: {
                values: Object.entries(value).map(function (_a) {
                    var _b = __read$1(_a, 2), k = _b[0], v = _b[1];
                    return toKeyValue(k, v);
                }),
            },
        };
    return {};
}

function sdkSpanToOtlpSpan(span, encoder) {
    var _a;
    var ctx = span.spanContext();
    var status = span.status;
    return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a = ctx.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: toAttributes(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map(function (event) { return toOtlpSpanEvent(event, encoder); }),
        droppedEventsCount: span.droppedEventsCount,
        status: {
            // API and proto enums share the same values
            code: status.code,
            message: status.message,
        },
        links: span.links.map(function (link) { return toOtlpLink(link, encoder); }),
        droppedLinksCount: span.droppedLinksCount,
    };
}
function toOtlpLink(link, encoder) {
    var _a;
    return {
        attributes: link.attributes ? toAttributes(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0,
    };
}
function toOtlpSpanEvent(timedEvent, encoder) {
    return {
        attributes: timedEvent.attributes
            ? toAttributes(timedEvent.attributes)
            : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0,
    };
}

var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function createExportTraceServiceRequest(spans, options) {
    var encoder = getOtlpEncoder(options);
    return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder),
    };
}
function createResourceMap(readableSpans) {
    var e_1, _a;
    var resourceMap = new Map();
    try {
        for (var readableSpans_1 = __values(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
            var record = readableSpans_1_1.value;
            var ilmMap = resourceMap.get(record.resource);
            if (!ilmMap) {
                ilmMap = new Map();
                resourceMap.set(record.resource, ilmMap);
            }
            // TODO this is duplicated in basic tracer. Consolidate on a common helper in core
            var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || '') + ":" + (record.instrumentationLibrary.schemaUrl || '');
            var records = ilmMap.get(instrumentationLibraryKey);
            if (!records) {
                records = [];
                ilmMap.set(instrumentationLibraryKey, records);
            }
            records.push(record);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, encoder) {
    var resourceMap = createResourceMap(readableSpans);
    var out = [];
    var entryIterator = resourceMap.entries();
    var entry = entryIterator.next();
    while (!entry.done) {
        var _a = __read(entry.value, 2), resource = _a[0], ilmMap = _a[1];
        var scopeResourceSpans = [];
        var ilmIterator = ilmMap.values();
        var ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
            var scopeSpans = ilmEntry.value;
            if (scopeSpans.length > 0) {
                var _b = scopeSpans[0].instrumentationLibrary, name_1 = _b.name, version = _b.version, schemaUrl = _b.schemaUrl;
                var spans = scopeSpans.map(function (readableSpan) {
                    return sdkSpanToOtlpSpan(readableSpan, encoder);
                });
                scopeResourceSpans.push({
                    scope: { name: name_1, version: version },
                    spans: spans,
                    schemaUrl: schemaUrl,
                });
            }
            ilmEntry = ilmIterator.next();
        }
        // TODO SDK types don't provide resource schema URL at this time
        var transformedSpans = {
            resource: {
                attributes: toAttributes(resource.attributes),
                droppedAttributesCount: 0,
            },
            scopeSpans: scopeResourceSpans,
            schemaUrl: undefined,
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var DEFAULT_COLLECTOR_RESOURCE_PATH = 'v1/traces';
var DEFAULT_COLLECTOR_URL = "http://localhost:4318/" + DEFAULT_COLLECTOR_RESOURCE_PATH;
/**
 * Collector Trace Exporter for Web
 */
var OTLPTraceExporter = /** @class */ (function (_super) {
    __extends(OTLPTraceExporter, _super);
    function OTLPTraceExporter(config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, config) || this;
        _this._headers = Object.assign(_this._headers, parseKeyPairsIntoRecord(getEnv().OTEL_EXPORTER_OTLP_TRACES_HEADERS));
        return _this;
    }
    OTLPTraceExporter.prototype.convert = function (spans) {
        return createExportTraceServiceRequest(spans, {
            useHex: true,
            useLongBits: false,
        });
    };
    OTLPTraceExporter.prototype.getDefaultUrl = function (config) {
        return typeof config.url === 'string'
            ? config.url
            : getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT.length > 0
                ? appendRootPathToUrlIfNeeded(getEnv().OTEL_EXPORTER_OTLP_TRACES_ENDPOINT)
                : getEnv().OTEL_EXPORTER_OTLP_ENDPOINT.length > 0
                    ? appendResourcePathToUrl(getEnv().OTEL_EXPORTER_OTLP_ENDPOINT, DEFAULT_COLLECTOR_RESOURCE_PATH)
                    : DEFAULT_COLLECTOR_URL;
    };
    return OTLPTraceExporter;
}(OTLPExporterBrowserBase));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * This attribute represents the state of the application.
 *
 * @example created
 *
 * @note The Android lifecycle states are defined in [Activity lifecycle callbacks](https://developer.android.com/guide/components/activities/activity-lifecycle#lc), and from which the `OS identifiers` are derived.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
/**
 * Name of the [deployment environment](https://wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
 *
 * @example staging
 * @example production
 *
 * @note `deployment.environment.name` does not affect the uniqueness constraints defined through
 * the `service.namespace`, `service.name` and `service.instance.id` resource attributes.
 * This implies that resources carrying the following attribute combinations **MUST** be
 * considered to be identifying the same service:
 *
 *   - `service.name=frontend`, `deployment.environment.name=production`
 *   - `service.name=frontend`, `deployment.environment.name=staging`.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
const ATTR_DEPLOYMENT_ENVIRONMENT_NAME = 'deployment.environment.name';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const otperformance$3 = performance;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TRACE_PARENT_HEADER = 'traceparent';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AttributeNames$3;
(function (AttributeNames) {
    AttributeNames["DOCUMENT_LOAD"] = "documentLoad";
    AttributeNames["DOCUMENT_FETCH"] = "documentFetch";
    AttributeNames["RESOURCE_FETCH"] = "resourceFetch";
})(AttributeNames$3 || (AttributeNames$3 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
const PACKAGE_VERSION$1 = '0.46.0';
const PACKAGE_NAME$1 = '@opentelemetry/instrumentation-document-load';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EventNames$1;
(function (EventNames) {
    EventNames["FIRST_PAINT"] = "firstPaint";
    EventNames["FIRST_CONTENTFUL_PAINT"] = "firstContentfulPaint";
})(EventNames$1 || (EventNames$1 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getPerformanceNavigationEntries = () => {
    const entries = {};
    const performanceNavigationTiming = otperformance$3.getEntriesByType?.('navigation')[0];
    if (performanceNavigationTiming) {
        const keys = Object.values(PerformanceTimingNames);
        keys.forEach((key) => {
            if (hasKey(performanceNavigationTiming, key)) {
                const value = performanceNavigationTiming[key];
                if (typeof value === 'number') {
                    entries[key] = value;
                }
            }
        });
    }
    else {
        // // fallback to previous version
        const perf = otperformance$3;
        const performanceTiming = perf.timing;
        if (performanceTiming) {
            const keys = Object.values(PerformanceTimingNames);
            keys.forEach((key) => {
                if (hasKey(performanceTiming, key)) {
                    const value = performanceTiming[key];
                    if (typeof value === 'number') {
                        entries[key] = value;
                    }
                }
            });
        }
    }
    return entries;
};
const performancePaintNames = {
    'first-paint': EventNames$1.FIRST_PAINT,
    'first-contentful-paint': EventNames$1.FIRST_CONTENTFUL_PAINT,
};
const addSpanPerformancePaintEvents = (span) => {
    const performancePaintTiming = otperformance$3.getEntriesByType?.('paint');
    if (performancePaintTiming) {
        performancePaintTiming.forEach(({ name, startTime }) => {
            if (hasKey(performancePaintNames, name)) {
                span.addEvent(performancePaintNames[name], startTime);
            }
        });
    }
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class represents a document load plugin
 */
class DocumentLoadInstrumentation extends InstrumentationBase {
    component = 'document-load';
    version = '1';
    moduleName = this.component;
    constructor(config = {}) {
        super(PACKAGE_NAME$1, PACKAGE_VERSION$1, config);
    }
    init() { }
    /**
     * callback to be executed when page is loaded
     */
    _onDocumentLoaded() {
        // Timeout is needed as load event doesn't have yet the performance metrics for loadEnd.
        // Support for event "loadend" is very limited and cannot be used
        window.setTimeout(() => {
            this._collectPerformance();
        });
    }
    /**
     * Adds spans for all resources
     * @param rootSpan
     */
    _addResourcesSpans(rootSpan) {
        const resources = otperformance$3.getEntriesByType?.('resource');
        if (resources) {
            resources.forEach(resource => {
                this._initResourceSpan(resource, rootSpan);
            });
        }
    }
    /**
     * Collects information about performance and creates appropriate spans
     */
    _collectPerformance() {
        const metaElement = Array.from(document.getElementsByTagName('meta')).find(e => e.getAttribute('name') === TRACE_PARENT_HEADER);
        const entries = getPerformanceNavigationEntries();
        const traceparent = (metaElement && metaElement.content) || '';
        context.with(propagation.extract(ROOT_CONTEXT, { traceparent }), () => {
            const rootSpan = this._startSpan(AttributeNames$3.DOCUMENT_LOAD, PerformanceTimingNames.FETCH_START, entries);
            if (!rootSpan) {
                return;
            }
            context.with(trace.setSpan(context.active(), rootSpan), () => {
                const fetchSpan = this._startSpan(AttributeNames$3.DOCUMENT_FETCH, PerformanceTimingNames.FETCH_START, entries);
                if (fetchSpan) {
                    fetchSpan.setAttribute(SEMATTRS_HTTP_URL, location.href);
                    context.with(trace.setSpan(context.active(), fetchSpan), () => {
                        if (!this.getConfig().ignoreNetworkEvents) {
                            addSpanNetworkEvents(fetchSpan, entries);
                        }
                        this._addCustomAttributesOnSpan(fetchSpan, this.getConfig().applyCustomAttributesOnSpan?.documentFetch);
                        this._endSpan(fetchSpan, PerformanceTimingNames.RESPONSE_END, entries);
                    });
                }
            });
            rootSpan.setAttribute(SEMATTRS_HTTP_URL, location.href);
            rootSpan.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);
            this._addResourcesSpans(rootSpan);
            if (!this.getConfig().ignoreNetworkEvents) {
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.FETCH_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.UNLOAD_EVENT_END, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_INTERACTIVE, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_CONTENT_LOADED_EVENT_END, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.DOM_COMPLETE, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_START, entries);
                addSpanNetworkEvent(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
            }
            if (!this.getConfig().ignorePerformancePaintEvents) {
                addSpanPerformancePaintEvents(rootSpan);
            }
            this._addCustomAttributesOnSpan(rootSpan, this.getConfig().applyCustomAttributesOnSpan?.documentLoad);
            this._endSpan(rootSpan, PerformanceTimingNames.LOAD_EVENT_END, entries);
        });
    }
    /**
     * Helper function for ending span
     * @param span
     * @param performanceName name of performance entry for time end
     * @param entries
     */
    _endSpan(span, performanceName, entries) {
        // span can be undefined when entries are missing the certain performance - the span will not be created
        if (span) {
            if (hasKey(entries, performanceName)) {
                span.end(entries[performanceName]);
            }
            else {
                // just end span
                span.end();
            }
        }
    }
    /**
     * Creates and ends a span with network information about resource added as timed events
     * @param resource
     * @param parentSpan
     */
    _initResourceSpan(resource, parentSpan) {
        const span = this._startSpan(AttributeNames$3.RESOURCE_FETCH, PerformanceTimingNames.FETCH_START, resource, parentSpan);
        if (span) {
            span.setAttribute(SEMATTRS_HTTP_URL, resource.name);
            if (!this.getConfig().ignoreNetworkEvents) {
                addSpanNetworkEvents(span, resource);
            }
            this._addCustomAttributesOnResourceSpan(span, resource, this.getConfig().applyCustomAttributesOnSpan?.resourceFetch);
            this._endSpan(span, PerformanceTimingNames.RESPONSE_END, resource);
        }
    }
    /**
     * Helper function for starting a span
     * @param spanName name of span
     * @param performanceName name of performance entry for time start
     * @param entries
     * @param parentSpan
     */
    _startSpan(spanName, performanceName, entries, parentSpan) {
        if (hasKey(entries, performanceName) &&
            typeof entries[performanceName] === 'number') {
            const span = this.tracer.startSpan(spanName, {
                startTime: entries[performanceName],
            }, parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined);
            return span;
        }
        return undefined;
    }
    /**
     * executes callback {_onDocumentLoaded} when the page is loaded
     */
    _waitForPageLoad() {
        if (window.document.readyState === 'complete') {
            this._onDocumentLoaded();
        }
        else {
            this._onDocumentLoaded = this._onDocumentLoaded.bind(this);
            window.addEventListener('load', this._onDocumentLoaded);
        }
    }
    /**
     * adds custom attributes to root span if configured
     */
    _addCustomAttributesOnSpan(span, applyCustomAttributesOnSpan) {
        if (applyCustomAttributesOnSpan) {
            safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span), error => {
                if (!error) {
                    return;
                }
                this._diag.error('addCustomAttributesOnSpan', error);
            });
        }
    }
    /**
     * adds custom attributes to span if configured
     */
    _addCustomAttributesOnResourceSpan(span, resource, applyCustomAttributesOnSpan) {
        if (applyCustomAttributesOnSpan) {
            safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, resource), error => {
                if (!error) {
                    return;
                }
                this._diag.error('addCustomAttributesOnResourceSpan', error);
            });
        }
    }
    /**
     * implements enable function
     */
    enable() {
        // remove previously attached load to avoid adding the same event twice
        // in case of multiple enable calling.
        window.removeEventListener('load', this._onDocumentLoaded);
        this._waitForPageLoad();
    }
    /**
     * implements disable function
     */
    disable() {
        window.removeEventListener('load', this._onDocumentLoaded);
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Updates to this file should also be replicated to @opentelemetry/api too.
/**
 * - globalThis (New standard)
 * - self (Will return the current window instance for supported browsers)
 * - window (fallback for older browser implementations)
 * - global (NodeJS implementation)
 * - <object> (When all else fails)
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
const _globalThis = typeof globalThis === 'object'
    ? globalThis
    : typeof self === 'object'
        ? self
        : typeof window === 'object'
            ? window
            : typeof global === 'object'
                ? global
                : {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const otperformance$2 = performance;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NANOSECOND_DIGITS$2 = 9;
const NANOSECOND_DIGITS_IN_MILLIS$2 = 6;
const MILLISECONDS_TO_NANOSECONDS$2 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS$2);
const SECOND_TO_NANOSECONDS$2 = Math.pow(10, NANOSECOND_DIGITS$2);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */
function millisToHrTime$2(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    // Decimals only.
    const seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS$2);
    return [seconds, nanos];
}
function getTimeOrigin$2() {
    let timeOrigin = otperformance$2.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        const perf = otperformance$2;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime$2(performanceNow) {
    const timeOrigin = millisToHrTime$2(getTimeOrigin$2());
    const now = millisToHrTime$2(otperformance$2.now());
    return addHrTimes$2(timeOrigin, now);
}
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */
function addHrTimes$2(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS$2) {
        out[1] -= SECOND_TO_NANOSECONDS$2;
        out[0] += 1;
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlMatches$1(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function isUrlIgnored$1(url, ignoredUrls) {
    if (!ignoredUrls) {
        return false;
    }
    for (const ignoreUrl of ignoredUrls) {
        if (urlMatches$1(url, ignoreUrl)) {
            return true;
        }
    }
    return false;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md
 */
var AttributeNames$2;
(function (AttributeNames) {
    AttributeNames["COMPONENT"] = "component";
    AttributeNames["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames$2 || (AttributeNames$2 = {}));

var semconv = {};

var hasRequiredSemconv;

function requireSemconv () {
	if (hasRequiredSemconv) return semconv;
	hasRequiredSemconv = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(semconv, "__esModule", { value: true });
	semconv.ATTR_HTTP_USER_AGENT = semconv.ATTR_HTTP_URL = semconv.ATTR_HTTP_STATUS_CODE = semconv.ATTR_HTTP_SCHEME = semconv.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = semconv.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = semconv.ATTR_HTTP_REQUEST_BODY_SIZE = semconv.ATTR_HTTP_METHOD = semconv.ATTR_HTTP_HOST = void 0;
	/*
	 * This file contains a copy of unstable semantic convention definitions
	 * used by this package.
	 * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv
	 */
	/**
	 * Deprecated, use one of `server.address`, `client.address` or `http.request.header.host` instead, depending on the usage.
	 *
	 * @example www.example.org
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by one of `server.address`, `client.address` or `http.request.header.host`, depending on the usage.
	 */
	semconv.ATTR_HTTP_HOST = 'http.host';
	/**
	 * Deprecated, use `http.request.method` instead.
	 *
	 * @example GET
	 * @example POST
	 * @example HEAD
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `http.request.method`.
	 */
	semconv.ATTR_HTTP_METHOD = 'http.method';
	/**
	 * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.
	 *
	 * @example 3495
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 */
	semconv.ATTR_HTTP_REQUEST_BODY_SIZE = 'http.request.body.size';
	/**
	 * Deprecated, use `http.request.body.size` instead.
	 *
	 * @example 5493
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `http.request.body.size`.
	 */
	semconv.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = 'http.request_content_length_uncompressed';
	/**
	 * Deprecated, use `http.response.header.<key>` instead.
	 *
	 * @example 3495
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `http.response.header.<key>`.
	 */
	semconv.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length';
	/**
	 * Deprecated, use `url.scheme` instead.
	 *
	 * @example http
	 * @example https
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `url.scheme` instead.
	 */
	semconv.ATTR_HTTP_SCHEME = 'http.scheme';
	/**
	 * Deprecated, use `http.response.status_code` instead.
	 *
	 * @example 200
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `http.response.status_code`.
	 */
	semconv.ATTR_HTTP_STATUS_CODE = 'http.status_code';
	/**
	 * Deprecated, use `url.full` instead.
	 *
	 * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `url.full`.
	 */
	semconv.ATTR_HTTP_URL = 'http.url';
	/**
	 * Deprecated, use `user_agent.original` instead.
	 *
	 * @example CERN-LineMode/2.15 libwww/2.17b3
	 * @example Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1
	 *
	 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
	 *
	 * @deprecated Replaced by `user_agent.original`.
	 */
	semconv.ATTR_HTTP_USER_AGENT = 'http.user_agent';
	
	return semconv;
}

var semconvExports = /*@__PURE__*/ requireSemconv();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-xml-http-request
// These may be unified in the future.
const DIAG_LOGGER$1 = diag.createComponentLogger({
    namespace: '@opentelemetry/opentelemetry-instrumentation-fetch/utils',
});
/**
 * Helper function to determine payload content length for fetch requests
 *
 * The fetch API is kinda messy: there are a couple of ways the body can be passed in.
 *
 * In all cases, the body param can be some variation of ReadableStream,
 * and ReadableStreams can only be read once! We want to avoid consuming the body here,
 * because that would mean that the body never gets sent with the actual fetch request.
 *
 * Either the first arg is a Request object, which can be cloned
 *   so we can clone that object and read the body of the clone
 *   without disturbing the original argument
 *   However, reading the body here can only be done async; the body() method returns a promise
 *   this means this entire function has to return a promise
 *
 * OR the first arg is a url/string
 *   in which case the second arg has type RequestInit
 *   RequestInit is NOT cloneable, but RequestInit.body is writable
 *   so we can chain it into ReadableStream.pipeThrough()
 *
 *   ReadableStream.pipeThrough() lets us process a stream and returns a new stream
 *   So we can measure the body length as it passes through the pie, but need to attach
 *   the new stream to the original request
 *   so that the browser still has access to the body.
 *
 * @param body
 * @returns promise that resolves to the content length of the body
 */
function getFetchBodyLength(...args) {
    if (args[0] instanceof URL || typeof args[0] === 'string') {
        const requestInit = args[1];
        if (!requestInit?.body) {
            return Promise.resolve();
        }
        if (requestInit.body instanceof ReadableStream) {
            const { body, length } = _getBodyNonDestructively(requestInit.body);
            requestInit.body = body;
            return length;
        }
        else {
            return Promise.resolve(getXHRBodyLength$1(requestInit.body));
        }
    }
    else {
        const info = args[0];
        if (!info?.body) {
            return Promise.resolve();
        }
        return info
            .clone()
            .text()
            .then(t => getByteLength$1(t));
    }
}
function _getBodyNonDestructively(body) {
    // can't read a ReadableStream without destroying it
    // but we CAN pipe it through and return a new ReadableStream
    // some (older) platforms don't expose the pipeThrough method and in that scenario, we're out of luck;
    //   there's no way to read the stream without consuming it.
    if (!body.pipeThrough) {
        DIAG_LOGGER$1.warn('Platform has ReadableStream but not pipeThrough!');
        return {
            body,
            length: Promise.resolve(undefined),
        };
    }
    let length = 0;
    let resolveLength;
    const lengthPromise = new Promise(resolve => {
        resolveLength = resolve;
    });
    const transform = new TransformStream({
        start() { },
        async transform(chunk, controller) {
            const bytearray = (await chunk);
            length += bytearray.byteLength;
            controller.enqueue(chunk);
        },
        flush() {
            resolveLength(length);
        },
    });
    return {
        body: body.pipeThrough(transform),
        length: lengthPromise,
    };
}
function isDocument$1(value) {
    return typeof Document !== 'undefined' && value instanceof Document;
}
/**
 * Helper function to determine payload content length for XHR requests
 * @param body
 * @returns content length
 */
function getXHRBodyLength$1(body) {
    if (isDocument$1(body)) {
        return new XMLSerializer().serializeToString(document).length;
    }
    // XMLHttpRequestBodyInit expands to the following:
    if (typeof body === 'string') {
        return getByteLength$1(body);
    }
    if (body instanceof Blob) {
        return body.size;
    }
    if (body instanceof FormData) {
        return getFormDataSize$1(body);
    }
    if (body instanceof URLSearchParams) {
        return getByteLength$1(body.toString());
    }
    // ArrayBuffer | ArrayBufferView
    if (body.byteLength !== undefined) {
        return body.byteLength;
    }
    DIAG_LOGGER$1.warn('unknown body type');
    return undefined;
}
const TEXT_ENCODER$1 = new TextEncoder();
function getByteLength$1(s) {
    return TEXT_ENCODER$1.encode(s).byteLength;
}
function getFormDataSize$1(formData) {
    let size = 0;
    for (const [key, value] of formData.entries()) {
        size += key.length;
        if (value instanceof Blob) {
            size += value.size;
        }
        else {
            size += value.length;
        }
    }
    return size;
}
/**
 * Normalize an HTTP request method string per `http.request.method` spec
 * https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#http-client-span
 */
function normalizeHttpRequestMethod$1(method) {
    const knownMethods = getKnownMethods$1();
    const methUpper = method.toUpperCase();
    if (methUpper in knownMethods) {
        return methUpper;
    }
    else {
        return '_OTHER';
    }
}
const DEFAULT_KNOWN_METHODS$1 = {
    CONNECT: true,
    DELETE: true,
    GET: true,
    HEAD: true,
    OPTIONS: true,
    PATCH: true,
    POST: true,
    PUT: true,
    TRACE: true,
};
let knownMethods$1;
function getKnownMethods$1() {
    if (knownMethods$1 === undefined) {
        {
            knownMethods$1 = DEFAULT_KNOWN_METHODS$1;
        }
    }
    return knownMethods$1;
}
const HTTP_PORT_FROM_PROTOCOL$1 = {
    'https:': '443',
    'http:': '80',
};
function serverPortFromUrl$1(url) {
    const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL$1[url.protocol]);
    // Guard with `if (serverPort)` because `Number('') === 0`.
    if (serverPort && !isNaN(serverPort)) {
        return serverPort;
    }
    else {
        return undefined;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
const VERSION$1 = '0.201.1';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// how long to wait for observer to collect information about resources
// this is needed as event "load" is called before observer
// hard to say how long it should really wait, seems like 300ms is
// safe enough
const OBSERVER_WAIT_TIME_MS$1 = 300;
const isNode = typeof process === 'object' && process.release?.name === 'node';
/**
 * This class represents a fetch plugin for auto instrumentation
 */
class FetchInstrumentation extends InstrumentationBase {
    component = 'fetch';
    version = VERSION$1;
    moduleName = this.component;
    _usedResources = new WeakSet();
    _tasksCount = 0;
    _semconvStability;
    constructor(config = {}) {
        super('@opentelemetry/instrumentation-fetch', VERSION$1, config);
        this._semconvStability = semconvStabilityFromStr('http', config?.semconvStabilityOptIn);
    }
    init() { }
    /**
     * Add cors pre flight child span
     * @param span
     * @param corsPreFlightRequest
     */
    _addChildSpan(span, corsPreFlightRequest) {
        const childSpan = this.tracer.startSpan('CORS Preflight', {
            startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START],
        }, trace.setSpan(context.active(), span));
        const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
        addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);
        childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
    }
    /**
     * Adds more attributes to span just before ending it
     * @param span
     * @param response
     */
    _addFinalSpanAttributes(span, response) {
        const parsedUrl = parseUrl(response.url);
        if (this._semconvStability & SemconvStability.OLD) {
            span.setAttribute(semconvExports.ATTR_HTTP_STATUS_CODE, response.status);
            if (response.statusText != null) {
                span.setAttribute(AttributeNames$2.HTTP_STATUS_TEXT, response.statusText);
            }
            span.setAttribute(semconvExports.ATTR_HTTP_HOST, parsedUrl.host);
            span.setAttribute(semconvExports.ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));
            if (typeof navigator !== 'undefined') {
                span.setAttribute(semconvExports.ATTR_HTTP_USER_AGENT, navigator.userAgent);
            }
        }
        if (this._semconvStability & SemconvStability.STABLE) {
            span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);
            // TODO: Set server.{address,port} at span creation for sampling decisions
            // (a "SHOULD" requirement in semconv).
            span.setAttribute(ATTR_SERVER_ADDRESS, parsedUrl.hostname);
            const serverPort = serverPortFromUrl$1(parsedUrl);
            if (serverPort) {
                span.setAttribute(ATTR_SERVER_PORT, serverPort);
            }
        }
    }
    /**
     * Add headers
     * @param options
     * @param spanUrl
     */
    _addHeaders(options, spanUrl) {
        if (!shouldPropagateTraceHeaders(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {
            const headers = {};
            propagation.inject(context.active(), headers);
            if (Object.keys(headers).length > 0) {
                this._diag.debug('headers inject skipped due to CORS policy');
            }
            return;
        }
        if (options instanceof Request) {
            propagation.inject(context.active(), options.headers, {
                set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),
            });
        }
        else if (options.headers instanceof Headers) {
            propagation.inject(context.active(), options.headers, {
                set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),
            });
        }
        else if (options.headers instanceof Map) {
            propagation.inject(context.active(), options.headers, {
                set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),
            });
        }
        else {
            const headers = {};
            propagation.inject(context.active(), headers);
            options.headers = Object.assign({}, headers, options.headers || {});
        }
    }
    /**
     * Clears the resource timings and all resources assigned with spans
     *     when {@link FetchPluginConfig.clearTimingResources} is
     *     set to true (default false)
     * @private
     */
    _clearResources() {
        if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
            performance.clearResourceTimings();
            this._usedResources = new WeakSet();
        }
    }
    /**
     * Creates a new span
     * @param url
     * @param options
     */
    _createSpan(url, options = {}) {
        if (isUrlIgnored$1(url, this.getConfig().ignoreUrls)) {
            this._diag.debug('ignoring span as url matches ignored url');
            return;
        }
        let name = '';
        const attributes = {};
        if (this._semconvStability & SemconvStability.OLD) {
            const method = (options.method || 'GET').toUpperCase();
            name = `HTTP ${method}`;
            attributes[AttributeNames$2.COMPONENT] = this.moduleName;
            attributes[semconvExports.ATTR_HTTP_METHOD] = method;
            attributes[semconvExports.ATTR_HTTP_URL] = url;
        }
        if (this._semconvStability & SemconvStability.STABLE) {
            const origMethod = options.method;
            const normMethod = normalizeHttpRequestMethod$1(options.method || 'GET');
            if (!name) {
                // The "old" span name wins if emitting both old and stable semconv
                // ('http/dup').
                name = normMethod;
            }
            attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;
            if (normMethod !== origMethod) {
                attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;
            }
            attributes[ATTR_URL_FULL] = url;
        }
        return this.tracer.startSpan(name, {
            kind: SpanKind.CLIENT,
            attributes,
        });
    }
    /**
     * Finds appropriate resource and add network events to the span
     * @param span
     * @param resourcesObserver
     * @param endTime
     */
    _findResourceAndAddNetworkEvents(span, resourcesObserver, endTime) {
        let resources = resourcesObserver.entries;
        if (!resources.length) {
            if (!performance.getEntriesByType) {
                return;
            }
            // fallback - either Observer is not available or it took longer
            // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough
            // information
            resources = performance.getEntriesByType('resource');
        }
        const resource = getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, 'fetch');
        if (resource.mainRequest) {
            const mainRequest = resource.mainRequest;
            this._markResourceAsUsed(mainRequest);
            const corsPreFlightRequest = resource.corsPreFlightRequest;
            if (corsPreFlightRequest) {
                this._addChildSpan(span, corsPreFlightRequest);
                this._markResourceAsUsed(corsPreFlightRequest);
            }
            const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
            addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);
        }
    }
    /**
     * Marks certain [resource]{@link PerformanceResourceTiming} when information
     * from this is used to add events to span.
     * This is done to avoid reusing the same resource again for next span
     * @param resource
     */
    _markResourceAsUsed(resource) {
        this._usedResources.add(resource);
    }
    /**
     * Finish span, add attributes, network events etc.
     * @param span
     * @param spanData
     * @param response
     */
    _endSpan(span, spanData, response) {
        const endTime = millisToHrTime$2(Date.now());
        const performanceEndTime = hrTime$2();
        this._addFinalSpanAttributes(span, response);
        if (this._semconvStability & SemconvStability.STABLE) {
            // https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#status
            if (response.status >= 400) {
                span.setStatus({ code: SpanStatusCode.ERROR });
                span.setAttribute(ATTR_ERROR_TYPE, String(response.status));
            }
        }
        setTimeout(() => {
            spanData.observer?.disconnect();
            this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);
            this._tasksCount--;
            this._clearResources();
            span.end(endTime);
        }, OBSERVER_WAIT_TIME_MS$1);
    }
    /**
     * Patches the constructor of fetch
     */
    _patchConstructor() {
        return original => {
            const plugin = this;
            return function patchConstructor(...args) {
                const self = this;
                const url = parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;
                const options = args[0] instanceof Request ? args[0] : args[1] || {};
                const createdSpan = plugin._createSpan(url, options);
                if (!createdSpan) {
                    return original.apply(this, args);
                }
                const spanData = plugin._prepareSpanData(url);
                if (plugin.getConfig().measureRequestSize) {
                    getFetchBodyLength(...args)
                        .then(bodyLength => {
                        if (!bodyLength)
                            return;
                        if (plugin._semconvStability & SemconvStability.OLD) {
                            createdSpan.setAttribute(semconvExports.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
                        }
                        if (plugin._semconvStability & SemconvStability.STABLE) {
                            createdSpan.setAttribute(semconvExports.ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);
                        }
                    })
                        .catch(error => {
                        plugin._diag.warn('getFetchBodyLength', error);
                    });
                }
                function endSpanOnError(span, error) {
                    plugin._applyAttributesAfterFetch(span, options, error);
                    plugin._endSpan(span, spanData, {
                        status: error.status || 0,
                        statusText: error.message,
                        url,
                    });
                }
                function endSpanOnSuccess(span, response) {
                    plugin._applyAttributesAfterFetch(span, options, response);
                    if (response.status >= 200 && response.status < 400) {
                        plugin._endSpan(span, spanData, response);
                    }
                    else {
                        plugin._endSpan(span, spanData, {
                            status: response.status,
                            statusText: response.statusText,
                            url,
                        });
                    }
                }
                function onSuccess(span, resolve, response) {
                    try {
                        const resClone = response.clone();
                        const body = resClone.body;
                        if (body) {
                            const reader = body.getReader();
                            const read = () => {
                                reader.read().then(({ done }) => {
                                    if (done) {
                                        endSpanOnSuccess(span, response);
                                    }
                                    else {
                                        read();
                                    }
                                }, error => {
                                    endSpanOnError(span, error);
                                });
                            };
                            read();
                        }
                        else {
                            // some older browsers don't have .body implemented
                            endSpanOnSuccess(span, response);
                        }
                    }
                    finally {
                        resolve(response);
                    }
                }
                function onError(span, reject, error) {
                    try {
                        endSpanOnError(span, error);
                    }
                    finally {
                        reject(error);
                    }
                }
                return new Promise((resolve, reject) => {
                    return context.with(trace.setSpan(context.active(), createdSpan), () => {
                        plugin._addHeaders(options, url);
                        // Important to execute "_callRequestHook" after "_addHeaders", allowing the consumer code to override the request headers.
                        plugin._callRequestHook(createdSpan, options);
                        plugin._tasksCount++;
                        // TypeScript complains about arrow function captured a this typed as globalThis
                        // ts(7041)
                        return original
                            .apply(self, options instanceof Request ? [options] : [url, options])
                            .then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));
                    });
                });
            };
        };
    }
    _applyAttributesAfterFetch(span, request, result) {
        const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
        if (applyCustomAttributesOnSpan) {
            safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, request, result), error => {
                if (!error) {
                    return;
                }
                this._diag.error('applyCustomAttributesOnSpan', error);
            });
        }
    }
    _callRequestHook(span, request) {
        const requestHook = this.getConfig().requestHook;
        if (requestHook) {
            safeExecuteInTheMiddle(() => requestHook(span, request), error => {
                if (!error) {
                    return;
                }
                this._diag.error('requestHook', error);
            });
        }
    }
    /**
     * Prepares a span data - needed later for matching appropriate network
     *     resources
     * @param spanUrl
     */
    _prepareSpanData(spanUrl) {
        const startTime = hrTime$2();
        const entries = [];
        if (typeof PerformanceObserver !== 'function') {
            return { entries, startTime, spanUrl };
        }
        const observer = new PerformanceObserver(list => {
            const perfObsEntries = list.getEntries();
            perfObsEntries.forEach(entry => {
                if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {
                    entries.push(entry);
                }
            });
        });
        observer.observe({
            entryTypes: ['resource'],
        });
        return { entries, observer, startTime, spanUrl };
    }
    /**
     * implements enable function
     */
    enable() {
        if (isNode) {
            // Node.js v18+ *does* have a global `fetch()`, but this package does not
            // support instrumenting it.
            this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
            return;
        }
        if (isWrapped(fetch)) {
            this._unwrap(_globalThis, 'fetch');
            this._diag.debug('removing previous patch for constructor');
        }
        this._wrap(_globalThis, 'fetch', this._patchConstructor());
    }
    /**
     * implements unpatch function
     */
    disable() {
        if (isNode) {
            return;
        }
        this._unwrap(_globalThis, 'fetch');
        this._usedResources = new WeakSet();
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const otperformance$1 = performance;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NANOSECOND_DIGITS$1 = 9;
const NANOSECOND_DIGITS_IN_MILLIS$1 = 6;
const MILLISECONDS_TO_NANOSECONDS$1 = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS$1);
const SECOND_TO_NANOSECONDS$1 = Math.pow(10, NANOSECOND_DIGITS$1);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */
function millisToHrTime$1(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    // Decimals only.
    const seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS$1);
    return [seconds, nanos];
}
function getTimeOrigin$1() {
    let timeOrigin = otperformance$1.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        const perf = otperformance$1;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime$1(performanceNow) {
    const timeOrigin = millisToHrTime$1(getTimeOrigin$1());
    const now = millisToHrTime$1(otperformance$1.now());
    return addHrTimes$1(timeOrigin, now);
}
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */
function addHrTimes$1(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS$1) {
        out[1] -= SECOND_TO_NANOSECONDS$1;
        out[0] += 1;
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var AttributeNames$1;
(function (AttributeNames) {
    AttributeNames["EVENT_TYPE"] = "event_type";
    AttributeNames["TARGET_ELEMENT"] = "target_element";
    AttributeNames["TARGET_XPATH"] = "target_xpath";
    AttributeNames["HTTP_URL"] = "http.url";
})(AttributeNames$1 || (AttributeNames$1 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
const PACKAGE_VERSION = '0.46.0';
const PACKAGE_NAME = '@opentelemetry/instrumentation-user-interaction';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="zone.js" />
const ZONE_CONTEXT_KEY = 'OT_ZONE_CONTEXT';
const EVENT_NAVIGATION_NAME = 'Navigation:';
const DEFAULT_EVENT_NAMES = ['click'];
function defaultShouldPreventSpanCreation() {
    return false;
}
/**
 * This class represents a UserInteraction plugin for auto instrumentation.
 * If zone.js is available then it patches the zone otherwise it patches
 * addEventListener of HTMLElement
 */
class UserInteractionInstrumentation extends InstrumentationBase {
    version = PACKAGE_VERSION;
    moduleName = 'user-interaction';
    _spansData = new WeakMap();
    // for addEventListener/removeEventListener state
    _wrappedListeners = new WeakMap();
    // for event bubbling
    _eventsSpanMap = new WeakMap();
    _eventNames;
    _shouldPreventSpanCreation;
    constructor(config = {}) {
        super(PACKAGE_NAME, PACKAGE_VERSION, config);
        this._eventNames = new Set(config?.eventNames ?? DEFAULT_EVENT_NAMES);
        this._shouldPreventSpanCreation =
            typeof config?.shouldPreventSpanCreation === 'function'
                ? config.shouldPreventSpanCreation
                : defaultShouldPreventSpanCreation;
    }
    init() { }
    /**
     * This will check if last task was timeout and will save the time to
     * fix the user interaction when nothing happens
     * This timeout comes from xhr plugin which is needed to collect information
     * about last xhr main request from observer
     * @param task
     * @param span
     */
    _checkForTimeout(task, span) {
        const spanData = this._spansData.get(span);
        if (spanData) {
            if (task.source === 'setTimeout') {
                spanData.hrTimeLastTimeout = hrTime$1();
            }
            else if (task.source !== 'Promise.then' &&
                task.source !== 'setTimeout') {
                spanData.hrTimeLastTimeout = undefined;
            }
        }
    }
    /**
     * Controls whether or not to create a span, based on the event type.
     */
    _allowEventName(eventName) {
        return this._eventNames.has(eventName);
    }
    /**
     * Creates a new span
     * @param element
     * @param eventName
     * @param parentSpan
     */
    _createSpan(element, eventName, parentSpan) {
        if (!(element instanceof HTMLElement)) {
            return undefined;
        }
        if (!element.getAttribute) {
            return undefined;
        }
        if (element.hasAttribute('disabled')) {
            return undefined;
        }
        if (!this._allowEventName(eventName)) {
            return undefined;
        }
        const xpath = getElementXPath(element, true);
        try {
            const span = this.tracer.startSpan(eventName, {
                attributes: {
                    [AttributeNames$1.EVENT_TYPE]: eventName,
                    [AttributeNames$1.TARGET_ELEMENT]: element.tagName,
                    [AttributeNames$1.TARGET_XPATH]: xpath,
                    [AttributeNames$1.HTTP_URL]: window.location.href,
                },
            }, parentSpan
                ? trace.setSpan(context.active(), parentSpan)
                : undefined);
            if (this._shouldPreventSpanCreation(eventName, element, span) === true) {
                return undefined;
            }
            this._spansData.set(span, {
                taskCount: 0,
            });
            return span;
        }
        catch (e) {
            this._diag.error('failed to start create new user interaction span', e);
        }
        return undefined;
    }
    /**
     * Decrement number of tasks that left in zone,
     * This is needed to be able to end span when no more tasks left
     * @param span
     */
    _decrementTask(span) {
        const spanData = this._spansData.get(span);
        if (spanData) {
            spanData.taskCount--;
            if (spanData.taskCount === 0) {
                this._tryToEndSpan(span, spanData.hrTimeLastTimeout);
            }
        }
    }
    /**
     * Return the current span
     * @param zone
     * @private
     */
    _getCurrentSpan(zone) {
        const context = zone.get(ZONE_CONTEXT_KEY);
        if (context) {
            return trace.getSpan(context);
        }
        return context;
    }
    /**
     * Increment number of tasks that are run within the same zone.
     *     This is needed to be able to end span when no more tasks left
     * @param span
     */
    _incrementTask(span) {
        const spanData = this._spansData.get(span);
        if (spanData) {
            spanData.taskCount++;
        }
    }
    /**
     * Returns true iff we should use the patched callback; false if it's already been patched
     */
    addPatchedListener(on, type, listener, wrappedListener) {
        let listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) {
            listener2Type = new Map();
            this._wrappedListeners.set(listener, listener2Type);
        }
        let element2patched = listener2Type.get(type);
        if (!element2patched) {
            element2patched = new Map();
            listener2Type.set(type, element2patched);
        }
        if (element2patched.has(on)) {
            return false;
        }
        element2patched.set(on, wrappedListener);
        return true;
    }
    /**
     * Returns the patched version of the callback (or undefined)
     */
    removePatchedListener(on, type, listener) {
        const listener2Type = this._wrappedListeners.get(listener);
        if (!listener2Type) {
            return undefined;
        }
        const element2patched = listener2Type.get(type);
        if (!element2patched) {
            return undefined;
        }
        const patched = element2patched.get(on);
        if (patched) {
            element2patched.delete(on);
            if (element2patched.size === 0) {
                listener2Type.delete(type);
                if (listener2Type.size === 0) {
                    this._wrappedListeners.delete(listener);
                }
            }
        }
        return patched;
    }
    // utility method to deal with the Function|EventListener nature of addEventListener
    _invokeListener(listener, target, args) {
        if (typeof listener === 'function') {
            return listener.apply(target, args);
        }
        else {
            return listener.handleEvent(args[0]);
        }
    }
    /**
     * This patches the addEventListener of HTMLElement to be able to
     * auto instrument the click events
     * This is done when zone is not available
     */
    _patchAddEventListener() {
        const plugin = this;
        return (original) => {
            return function addEventListenerPatched(type, listener, useCapture) {
                // Forward calls with listener = null
                if (!listener) {
                    return original.call(this, type, listener, useCapture);
                }
                // filter out null (typeof null === 'object')
                const once = useCapture && typeof useCapture === 'object' && useCapture.once;
                const patchedListener = function (...args) {
                    let parentSpan;
                    const event = args[0];
                    const target = event?.target;
                    if (event) {
                        parentSpan = plugin._eventsSpanMap.get(event);
                    }
                    if (once) {
                        plugin.removePatchedListener(this, type, listener);
                    }
                    const span = plugin._createSpan(target, type, parentSpan);
                    if (span) {
                        if (event) {
                            plugin._eventsSpanMap.set(event, span);
                        }
                        return context.with(trace.setSpan(context.active(), span), () => {
                            const result = plugin._invokeListener(listener, this, args);
                            // no zone so end span immediately
                            span.end();
                            return result;
                        });
                    }
                    else {
                        return plugin._invokeListener(listener, this, args);
                    }
                };
                if (plugin.addPatchedListener(this, type, listener, patchedListener)) {
                    return original.call(this, type, patchedListener, useCapture);
                }
            };
        };
    }
    /**
     * This patches the removeEventListener of HTMLElement to handle the fact that
     * we patched the original callbacks
     * This is done when zone is not available
     */
    _patchRemoveEventListener() {
        const plugin = this;
        return (original) => {
            return function removeEventListenerPatched(type, listener, useCapture) {
                const wrappedListener = plugin.removePatchedListener(this, type, listener);
                if (wrappedListener) {
                    return original.call(this, type, wrappedListener, useCapture);
                }
                else {
                    return original.call(this, type, listener, useCapture);
                }
            };
        };
    }
    /**
     * Most browser provide event listener api via EventTarget in prototype chain.
     * Exception to this is IE 11 which has it on the prototypes closest to EventTarget:
     *
     * * - has addEventListener in IE
     * ** - has addEventListener in all other browsers
     * ! - missing in IE
     *
     * HTMLElement -> Element -> Node * -> EventTarget **! -> Object
     * Document -> Node * -> EventTarget **! -> Object
     * Window * -> WindowProperties ! -> EventTarget **! -> Object
     */
    _getPatchableEventTargets() {
        return window.EventTarget
            ? [EventTarget.prototype]
            : [Node.prototype, Window.prototype];
    }
    /**
     * Patches the history api
     */
    _patchHistoryApi() {
        this._unpatchHistoryApi();
        this._wrap(history, 'replaceState', this._patchHistoryMethod());
        this._wrap(history, 'pushState', this._patchHistoryMethod());
        this._wrap(history, 'back', this._patchHistoryMethod());
        this._wrap(history, 'forward', this._patchHistoryMethod());
        this._wrap(history, 'go', this._patchHistoryMethod());
    }
    /**
     * Patches the certain history api method
     */
    _patchHistoryMethod() {
        const plugin = this;
        return (original) => {
            return function patchHistoryMethod(...args) {
                const url = `${location.pathname}${location.hash}${location.search}`;
                const result = original.apply(this, args);
                const urlAfter = `${location.pathname}${location.hash}${location.search}`;
                if (url !== urlAfter) {
                    plugin._updateInteractionName(urlAfter);
                }
                return result;
            };
        };
    }
    /**
     * unpatch the history api methods
     */
    _unpatchHistoryApi() {
        if (isWrapped(history.replaceState))
            this._unwrap(history, 'replaceState');
        if (isWrapped(history.pushState))
            this._unwrap(history, 'pushState');
        if (isWrapped(history.back))
            this._unwrap(history, 'back');
        if (isWrapped(history.forward))
            this._unwrap(history, 'forward');
        if (isWrapped(history.go))
            this._unwrap(history, 'go');
    }
    /**
     * Updates interaction span name
     * @param url
     */
    _updateInteractionName(url) {
        const span = trace.getSpan(context.active());
        if (span && typeof span.updateName === 'function') {
            span.updateName(`${EVENT_NAVIGATION_NAME} ${url}`);
        }
    }
    /**
     * Patches zone cancel task - this is done to be able to correctly
     * decrement the number of remaining tasks
     */
    _patchZoneCancelTask() {
        const plugin = this;
        return (original) => {
            return function patchCancelTask(task) {
                const currentZone = Zone.current;
                const currentSpan = plugin._getCurrentSpan(currentZone);
                if (currentSpan && plugin._shouldCountTask(task, currentZone)) {
                    plugin._decrementTask(currentSpan);
                }
                return original.call(this, task);
            };
        };
    }
    /**
     * Patches zone schedule task - this is done to be able to correctly
     * increment the number of tasks running within current zone but also to
     * save time in case of timeout running from xhr plugin when waiting for
     * main request from PerformanceResourceTiming
     */
    _patchZoneScheduleTask() {
        const plugin = this;
        return (original) => {
            return function patchScheduleTask(task) {
                const currentZone = Zone.current;
                const currentSpan = plugin._getCurrentSpan(currentZone);
                if (currentSpan && plugin._shouldCountTask(task, currentZone)) {
                    plugin._incrementTask(currentSpan);
                    plugin._checkForTimeout(task, currentSpan);
                }
                return original.call(this, task);
            };
        };
    }
    /**
     * Patches zone run task - this is done to be able to create a span when
     * user interaction starts
     * @private
     */
    _patchZoneRunTask() {
        const plugin = this;
        return (original) => {
            return function patchRunTask(task, applyThis, applyArgs) {
                const event = Array.isArray(applyArgs) && applyArgs[0] instanceof Event
                    ? applyArgs[0]
                    : undefined;
                const target = event?.target;
                let span;
                const activeZone = this;
                if (target) {
                    span = plugin._createSpan(target, task.eventName);
                    if (span) {
                        plugin._incrementTask(span);
                        return activeZone.run(() => {
                            try {
                                return context.with(trace.setSpan(context.active(), span), () => {
                                    const currentZone = Zone.current;
                                    task._zone = currentZone;
                                    return original.call(currentZone, task, applyThis, applyArgs);
                                });
                            }
                            finally {
                                plugin._decrementTask(span);
                            }
                        });
                    }
                }
                else {
                    span = plugin._getCurrentSpan(activeZone);
                }
                try {
                    return original.call(activeZone, task, applyThis, applyArgs);
                }
                finally {
                    if (span && plugin._shouldCountTask(task, activeZone)) {
                        plugin._decrementTask(span);
                    }
                }
            };
        };
    }
    /**
     * Decides if task should be counted.
     * @param task
     * @param currentZone
     * @private
     */
    _shouldCountTask(task, currentZone) {
        if (task._zone) {
            currentZone = task._zone;
        }
        if (!currentZone || !task.data || task.data.isPeriodic) {
            return false;
        }
        const currentSpan = this._getCurrentSpan(currentZone);
        if (!currentSpan) {
            return false;
        }
        if (!this._spansData.get(currentSpan)) {
            return false;
        }
        return task.type === 'macroTask' || task.type === 'microTask';
    }
    /**
     * Will try to end span when such span still exists.
     * @param span
     * @param endTime
     * @private
     */
    _tryToEndSpan(span, endTime) {
        if (span) {
            const spanData = this._spansData.get(span);
            if (spanData) {
                span.end(endTime);
                this._spansData.delete(span);
            }
        }
    }
    /**
     * implements enable function
     */
    enable() {
        const ZoneWithPrototype = this._getZoneWithPrototype();
        this._diag.debug('applying patch to', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype) {
            if (isWrapped(ZoneWithPrototype.prototype.runTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'runTask');
                this._diag.debug('removing previous patch from method runTask');
            }
            if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
                this._diag.debug('removing previous patch from method scheduleTask');
            }
            if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
                this._diag.debug('removing previous patch from method cancelTask');
            }
            this._zonePatched = true;
            this._wrap(ZoneWithPrototype.prototype, 'runTask', this._patchZoneRunTask());
            this._wrap(ZoneWithPrototype.prototype, 'scheduleTask', this._patchZoneScheduleTask());
            this._wrap(ZoneWithPrototype.prototype, 'cancelTask', this._patchZoneCancelTask());
        }
        else {
            this._zonePatched = false;
            const targets = this._getPatchableEventTargets();
            targets.forEach(target => {
                if (isWrapped(target.addEventListener)) {
                    this._unwrap(target, 'addEventListener');
                    this._diag.debug('removing previous patch from method addEventListener');
                }
                if (isWrapped(target.removeEventListener)) {
                    this._unwrap(target, 'removeEventListener');
                    this._diag.debug('removing previous patch from method removeEventListener');
                }
                this._wrap(target, 'addEventListener', this._patchAddEventListener());
                this._wrap(target, 'removeEventListener', this._patchRemoveEventListener());
            });
        }
        this._patchHistoryApi();
    }
    /**
     * implements unpatch function
     */
    disable() {
        const ZoneWithPrototype = this._getZoneWithPrototype();
        this._diag.debug('removing patch from', this.moduleName, this.version, 'zone:', !!ZoneWithPrototype);
        if (ZoneWithPrototype && this._zonePatched) {
            if (isWrapped(ZoneWithPrototype.prototype.runTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'runTask');
            }
            if (isWrapped(ZoneWithPrototype.prototype.scheduleTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'scheduleTask');
            }
            if (isWrapped(ZoneWithPrototype.prototype.cancelTask)) {
                this._unwrap(ZoneWithPrototype.prototype, 'cancelTask');
            }
        }
        else {
            const targets = this._getPatchableEventTargets();
            targets.forEach(target => {
                if (isWrapped(target.addEventListener)) {
                    this._unwrap(target, 'addEventListener');
                }
                if (isWrapped(target.removeEventListener)) {
                    this._unwrap(target, 'removeEventListener');
                }
            });
        }
        this._unpatchHistoryApi();
    }
    /**
     * returns Zone
     */
    _getZoneWithPrototype() {
        const _window = window;
        return _window.Zone;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const otperformance = performance;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NANOSECOND_DIGITS = 9;
const NANOSECOND_DIGITS_IN_MILLIS = 6;
const MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
const SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */
function millisToHrTime(epochMillis) {
    const epochSeconds = epochMillis / 1000;
    // Decimals only.
    const seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
}
function getTimeOrigin() {
    let timeOrigin = otperformance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        const perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime(performanceNow) {
    const timeOrigin = millisToHrTime(getTimeOrigin());
    const now = millisToHrTime(otperformance.now());
    return addHrTimes(timeOrigin, now);
}
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */
function addHrTimes(time1, time2) {
    const out = [time1[0] + time2[0], time1[1] + time2[1]];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function isUrlIgnored(url, ignoredUrls) {
    if (!ignoredUrls) {
        return false;
    }
    for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
            return true;
        }
    }
    return false;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This file contains a copy of unstable semantic convention definitions
 * used by this package.
 * @see https://github.com/open-telemetry/opentelemetry-js/tree/main/semantic-conventions#unstable-semconv
 */
/**
 * Deprecated, use one of `server.address`, `client.address` or `http.request.header.host` instead, depending on the usage.
 *
 * @example www.example.org
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by one of `server.address`, `client.address` or `http.request.header.host`, depending on the usage.
 */
const ATTR_HTTP_HOST = 'http.host';
/**
 * Deprecated, use `http.request.method` instead.
 *
 * @example GET
 * @example POST
 * @example HEAD
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `http.request.method`.
 */
const ATTR_HTTP_METHOD = 'http.method';
/**
 * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.
 *
 * @example 3495
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
const ATTR_HTTP_REQUEST_BODY_SIZE = 'http.request.body.size';
/**
 * Deprecated, use `http.request.body.size` instead.
 *
 * @example 5493
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `http.request.body.size`.
 */
const ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = 'http.request_content_length_uncompressed';
/**
 * Deprecated, use `url.scheme` instead.
 *
 * @example http
 * @example https
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `url.scheme` instead.
 */
const ATTR_HTTP_SCHEME = 'http.scheme';
/**
 * Deprecated, use `http.response.status_code` instead.
 *
 * @example 200
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `http.response.status_code`.
 */
const ATTR_HTTP_STATUS_CODE = 'http.status_code';
/**
 * Deprecated, use `url.full` instead.
 *
 * @example https://www.foo.bar/search?q=OpenTelemetry#SemConv
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `url.full`.
 */
const ATTR_HTTP_URL = 'http.url';
/**
 * Deprecated, use `user_agent.original` instead.
 *
 * @example CERN-LineMode/2.15 libwww/2.17b3
 * @example Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 *
 * @deprecated Replaced by `user_agent.original`.
 */
const ATTR_HTTP_USER_AGENT = 'http.user_agent';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EventNames;
(function (EventNames) {
    EventNames["METHOD_OPEN"] = "open";
    EventNames["METHOD_SEND"] = "send";
    EventNames["EVENT_ABORT"] = "abort";
    EventNames["EVENT_ERROR"] = "error";
    EventNames["EVENT_LOAD"] = "loaded";
    EventNames["EVENT_TIMEOUT"] = "timeout";
})(EventNames || (EventNames = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-fetch
// These may be unified in the future.
const DIAG_LOGGER = diag.createComponentLogger({
    namespace: '@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils',
});
function isDocument(value) {
    return typeof Document !== 'undefined' && value instanceof Document;
}
/**
 * Helper function to determine payload content length for XHR requests
 * @param body
 * @returns content length
 */
function getXHRBodyLength(body) {
    if (isDocument(body)) {
        return new XMLSerializer().serializeToString(document).length;
    }
    // XMLHttpRequestBodyInit expands to the following:
    if (typeof body === 'string') {
        return getByteLength(body);
    }
    if (body instanceof Blob) {
        return body.size;
    }
    if (body instanceof FormData) {
        return getFormDataSize(body);
    }
    if (body instanceof URLSearchParams) {
        return getByteLength(body.toString());
    }
    // ArrayBuffer | ArrayBufferView
    if (body.byteLength !== undefined) {
        return body.byteLength;
    }
    DIAG_LOGGER.warn('unknown body type');
    return undefined;
}
const TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
    return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
    let size = 0;
    for (const [key, value] of formData.entries()) {
        size += key.length;
        if (value instanceof Blob) {
            size += value.size;
        }
        else {
            size += value.length;
        }
    }
    return size;
}
/**
 * Normalize an HTTP request method string per `http.request.method` spec
 * https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#http-client-span
 */
function normalizeHttpRequestMethod(method) {
    const knownMethods = getKnownMethods();
    const methUpper = method.toUpperCase();
    if (methUpper in knownMethods) {
        return methUpper;
    }
    else {
        return '_OTHER';
    }
}
const DEFAULT_KNOWN_METHODS = {
    CONNECT: true,
    DELETE: true,
    GET: true,
    HEAD: true,
    OPTIONS: true,
    PATCH: true,
    POST: true,
    PUT: true,
    TRACE: true,
};
let knownMethods;
function getKnownMethods() {
    if (knownMethods === undefined) {
        {
            knownMethods = DEFAULT_KNOWN_METHODS;
        }
    }
    return knownMethods;
}
const HTTP_PORT_FROM_PROTOCOL = {
    'https:': '443',
    'http:': '80',
};
function serverPortFromUrl(url) {
    const serverPort = Number(url.port || HTTP_PORT_FROM_PROTOCOL[url.protocol]);
    // Guard with `if (serverPort)` because `Number('') === 0`.
    if (serverPort && !isNaN(serverPort)) {
        return serverPort;
    }
    else {
        return undefined;
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
const VERSION = '0.201.1';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md
 */
var AttributeNames;
(function (AttributeNames) {
    AttributeNames["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// how long to wait for observer to collect information about resources
// this is needed as event "load" is called before observer
// hard to say how long it should really wait, seems like 300ms is
// safe enough
const OBSERVER_WAIT_TIME_MS = 300;
/**
 * This class represents a XMLHttpRequest plugin for auto instrumentation
 */
class XMLHttpRequestInstrumentation extends InstrumentationBase {
    component = 'xml-http-request';
    version = VERSION;
    moduleName = this.component;
    _tasksCount = 0;
    _xhrMem = new WeakMap();
    _usedResources = new WeakSet();
    _semconvStability;
    constructor(config = {}) {
        super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);
        this._semconvStability = semconvStabilityFromStr('http', config?.semconvStabilityOptIn);
    }
    init() { }
    /**
     * Adds custom headers to XMLHttpRequest
     * @param xhr
     * @param spanUrl
     * @private
     */
    _addHeaders(xhr, spanUrl) {
        const url = parseUrl(spanUrl).href;
        if (!shouldPropagateTraceHeaders(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
            const headers = {};
            propagation.inject(context.active(), headers);
            if (Object.keys(headers).length > 0) {
                this._diag.debug('headers inject skipped due to CORS policy');
            }
            return;
        }
        const headers = {};
        propagation.inject(context.active(), headers);
        Object.keys(headers).forEach(key => {
            xhr.setRequestHeader(key, String(headers[key]));
        });
    }
    /**
     * Add cors pre flight child span
     * @param span
     * @param corsPreFlightRequest
     * @private
     */
    _addChildSpan(span, corsPreFlightRequest) {
        context.with(trace.setSpan(context.active(), span), () => {
            const childSpan = this.tracer.startSpan('CORS Preflight', {
                startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START],
            });
            const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
            addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);
            childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
        });
    }
    /**
     * Add attributes when span is going to end
     * @param span
     * @param xhr
     * @param spanUrl
     * @private
     */
    _addFinalSpanAttributes(span, xhrMem, spanUrl) {
        if (this._semconvStability & SemconvStability.OLD) {
            if (xhrMem.status !== undefined) {
                span.setAttribute(ATTR_HTTP_STATUS_CODE, xhrMem.status);
            }
            if (xhrMem.statusText !== undefined) {
                span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);
            }
            if (typeof spanUrl === 'string') {
                const parsedUrl = parseUrl(spanUrl);
                span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);
                span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));
            }
            // @TODO do we want to collect this or it will be collected earlier once only or
            //    maybe when parent span is not available ?
            span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);
        }
        if (this._semconvStability & SemconvStability.STABLE) {
            if (xhrMem.status) {
                // Intentionally exclude status=0, because XHR uses 0 for before a
                // response is received and semconv says to only add the attribute if
                // received a response.
                span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, xhrMem.status);
            }
        }
    }
    _applyAttributesAfterXHR(span, xhr) {
        const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
        if (typeof applyCustomAttributesOnSpan === 'function') {
            safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, xhr), error => {
                if (!error) {
                    return;
                }
                this._diag.error('applyCustomAttributesOnSpan', error);
            });
        }
    }
    /**
     * will collect information about all resources created
     * between "send" and "end" with additional waiting for main resource
     * @param xhr
     * @param spanUrl
     * @private
     */
    _addResourceObserver(xhr, spanUrl) {
        const xhrMem = this._xhrMem.get(xhr);
        if (!xhrMem ||
            typeof PerformanceObserver !== 'function' ||
            typeof PerformanceResourceTiming !== 'function') {
            return;
        }
        xhrMem.createdResources = {
            observer: new PerformanceObserver(list => {
                const entries = list.getEntries();
                const parsedUrl = parseUrl(spanUrl);
                entries.forEach(entry => {
                    if (entry.initiatorType === 'xmlhttprequest' &&
                        entry.name === parsedUrl.href) {
                        if (xhrMem.createdResources) {
                            xhrMem.createdResources.entries.push(entry);
                        }
                    }
                });
            }),
            entries: [],
        };
        xhrMem.createdResources.observer.observe({
            entryTypes: ['resource'],
        });
    }
    /**
     * Clears the resource timings and all resources assigned with spans
     *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is
     *     set to true (default false)
     * @private
     */
    _clearResources() {
        if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
            otperformance.clearResourceTimings();
            this._xhrMem = new WeakMap();
            this._usedResources = new WeakSet();
        }
    }
    /**
     * Finds appropriate resource and add network events to the span
     * @param span
     */
    _findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, startTime, endTime) {
        if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {
            return;
        }
        let resources = xhrMem.createdResources.entries;
        if (!resources || !resources.length) {
            // fallback - either Observer is not available or it took longer
            // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough
            // information
            // ts thinks this is the perf_hooks module, but it is the browser performance api
            resources = otperformance.getEntriesByType('resource');
        }
        const resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);
        if (resource.mainRequest) {
            const mainRequest = resource.mainRequest;
            this._markResourceAsUsed(mainRequest);
            const corsPreFlightRequest = resource.corsPreFlightRequest;
            if (corsPreFlightRequest) {
                this._addChildSpan(span, corsPreFlightRequest);
                this._markResourceAsUsed(corsPreFlightRequest);
            }
            const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);
            addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);
        }
    }
    /**
     * Removes the previous information about span.
     * This might happened when the same xhr is used again.
     * @param xhr
     * @private
     */
    _cleanPreviousSpanInformation(xhr) {
        const xhrMem = this._xhrMem.get(xhr);
        if (xhrMem) {
            const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
            if (callbackToRemoveEvents) {
                callbackToRemoveEvents();
            }
            this._xhrMem.delete(xhr);
        }
    }
    /**
     * Creates a new span when method "open" is called
     * @param xhr
     * @param url
     * @param method
     * @private
     */
    _createSpan(xhr, url, method) {
        if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
            this._diag.debug('ignoring span as url matches ignored url');
            return;
        }
        let name = '';
        const parsedUrl = parseUrl(url);
        const attributes = {};
        if (this._semconvStability & SemconvStability.OLD) {
            name = method.toUpperCase();
            attributes[ATTR_HTTP_METHOD] = method;
            attributes[ATTR_HTTP_URL] = parsedUrl.toString();
        }
        if (this._semconvStability & SemconvStability.STABLE) {
            const origMethod = method;
            const normMethod = normalizeHttpRequestMethod(method);
            if (!name) {
                // The "old" span name wins if emitting both old and stable semconv
                // ('http/dup').
                name = normMethod;
            }
            attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;
            if (normMethod !== origMethod) {
                attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;
            }
            attributes[ATTR_URL_FULL] = parsedUrl.toString();
            attributes[ATTR_SERVER_ADDRESS] = parsedUrl.hostname;
            const serverPort = serverPortFromUrl(parsedUrl);
            if (serverPort) {
                attributes[ATTR_SERVER_PORT] = serverPort;
            }
        }
        const currentSpan = this.tracer.startSpan(name, {
            kind: SpanKind.CLIENT,
            attributes,
        });
        currentSpan.addEvent(EventNames.METHOD_OPEN);
        this._cleanPreviousSpanInformation(xhr);
        this._xhrMem.set(xhr, {
            span: currentSpan,
            spanUrl: url,
        });
        return currentSpan;
    }
    /**
     * Marks certain [resource]{@link PerformanceResourceTiming} when information
     * from this is used to add events to span.
     * This is done to avoid reusing the same resource again for next span
     * @param resource
     * @private
     */
    _markResourceAsUsed(resource) {
        this._usedResources.add(resource);
    }
    /**
     * Patches the method open
     * @private
     */
    _patchOpen() {
        return (original) => {
            const plugin = this;
            return function patchOpen(...args) {
                const method = args[0];
                const url = args[1];
                plugin._createSpan(this, url, method);
                return original.apply(this, args);
            };
        };
    }
    /**
     * Patches the method send
     * @private
     */
    _patchSend() {
        const plugin = this;
        function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
            const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
            if (typeof callbackToRemoveEvents === 'function') {
                callbackToRemoveEvents();
            }
            const { span, spanUrl, sendStartTime } = xhrMem;
            if (span) {
                plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
                span.addEvent(eventName, endTime);
                plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
                span.end(endTime);
                plugin._tasksCount--;
            }
            plugin._clearResources();
        }
        function endSpan(eventName, xhr, isError, errorType) {
            const xhrMem = plugin._xhrMem.get(xhr);
            if (!xhrMem) {
                return;
            }
            xhrMem.status = xhr.status;
            xhrMem.statusText = xhr.statusText;
            plugin._xhrMem.delete(xhr);
            if (xhrMem.span) {
                const span = xhrMem.span;
                plugin._applyAttributesAfterXHR(span, xhr);
                if (plugin._semconvStability & SemconvStability.STABLE) {
                    if (isError) {
                        if (errorType) {
                            span.setStatus({
                                code: SpanStatusCode.ERROR,
                                message: errorType,
                            });
                            span.setAttribute(ATTR_ERROR_TYPE, errorType);
                        }
                    }
                    else if (xhrMem.status && xhrMem.status >= 400) {
                        span.setStatus({ code: SpanStatusCode.ERROR });
                        span.setAttribute(ATTR_ERROR_TYPE, String(xhrMem.status));
                    }
                }
            }
            const performanceEndTime = hrTime();
            const endTime = Date.now();
            // the timeout is needed as observer doesn't have yet information
            // when event "load" is called. Also the time may differ depends on
            // browser and speed of computer
            setTimeout(() => {
                endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
            }, OBSERVER_WAIT_TIME_MS);
        }
        function onError() {
            endSpan(EventNames.EVENT_ERROR, this, true, 'error');
        }
        function onAbort() {
            endSpan(EventNames.EVENT_ABORT, this, false);
        }
        function onTimeout() {
            endSpan(EventNames.EVENT_TIMEOUT, this, true, 'timeout');
        }
        function onLoad() {
            if (this.status < 299) {
                endSpan(EventNames.EVENT_LOAD, this, false);
            }
            else {
                endSpan(EventNames.EVENT_ERROR, this, false);
            }
        }
        function unregister(xhr) {
            xhr.removeEventListener('abort', onAbort);
            xhr.removeEventListener('error', onError);
            xhr.removeEventListener('load', onLoad);
            xhr.removeEventListener('timeout', onTimeout);
            const xhrMem = plugin._xhrMem.get(xhr);
            if (xhrMem) {
                xhrMem.callbackToRemoveEvents = undefined;
            }
        }
        return (original) => {
            return function patchSend(...args) {
                const xhrMem = plugin._xhrMem.get(this);
                if (!xhrMem) {
                    return original.apply(this, args);
                }
                const currentSpan = xhrMem.span;
                const spanUrl = xhrMem.spanUrl;
                if (currentSpan && spanUrl) {
                    if (plugin.getConfig().measureRequestSize && args?.[0]) {
                        const body = args[0];
                        const bodyLength = getXHRBodyLength(body);
                        if (bodyLength !== undefined) {
                            if (plugin._semconvStability & SemconvStability.OLD) {
                                currentSpan.setAttribute(ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
                            }
                            if (plugin._semconvStability & SemconvStability.STABLE) {
                                currentSpan.setAttribute(ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);
                            }
                        }
                    }
                    context.with(trace.setSpan(context.active(), currentSpan), () => {
                        plugin._tasksCount++;
                        xhrMem.sendStartTime = hrTime();
                        currentSpan.addEvent(EventNames.METHOD_SEND);
                        this.addEventListener('abort', onAbort);
                        this.addEventListener('error', onError);
                        this.addEventListener('load', onLoad);
                        this.addEventListener('timeout', onTimeout);
                        xhrMem.callbackToRemoveEvents = () => {
                            unregister(this);
                            if (xhrMem.createdResources) {
                                xhrMem.createdResources.observer.disconnect();
                            }
                        };
                        plugin._addHeaders(this, spanUrl);
                        plugin._addResourceObserver(this, spanUrl);
                    });
                }
                return original.apply(this, args);
            };
        };
    }
    /**
     * implements enable function
     */
    enable() {
        this._diag.debug('applying patch to', this.moduleName, this.version);
        if (isWrapped(XMLHttpRequest.prototype.open)) {
            this._unwrap(XMLHttpRequest.prototype, 'open');
            this._diag.debug('removing previous patch from method open');
        }
        if (isWrapped(XMLHttpRequest.prototype.send)) {
            this._unwrap(XMLHttpRequest.prototype, 'send');
            this._diag.debug('removing previous patch from method send');
        }
        this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());
        this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());
    }
    /**
     * implements disable function
     */
    disable() {
        this._diag.debug('removing patch from', this.moduleName, this.version);
        this._unwrap(XMLHttpRequest.prototype, 'open');
        this._unwrap(XMLHttpRequest.prototype, 'send');
        this._tasksCount = 0;
        this._xhrMem = new WeakMap();
        this._usedResources = new WeakSet();
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const InstrumentationMap = {
    '@opentelemetry/instrumentation-document-load': DocumentLoadInstrumentation,
    '@opentelemetry/instrumentation-fetch': FetchInstrumentation,
    '@opentelemetry/instrumentation-user-interaction': UserInteractionInstrumentation,
    '@opentelemetry/instrumentation-xml-http-request': XMLHttpRequestInstrumentation,
};
function getWebAutoInstrumentations(inputConfigs = {}) {
    for (const name of Object.keys(inputConfigs)) {
        if (!Object.prototype.hasOwnProperty.call(InstrumentationMap, name)) {
            diag.error(`Provided instrumentation name "${name}" not found`);
            continue;
        }
    }
    const instrumentations = [];
    for (const name of Object.keys(InstrumentationMap)) {
        const Instance = InstrumentationMap[name];
        // Defaults are defined by the instrumentation itself
        const userConfig = inputConfigs[name] ?? {};
        if (userConfig.enabled === false) {
            diag.debug(`Disabling instrumentation for ${name}`);
            continue;
        }
        try {
            diag.debug(`Loading instrumentation for ${name}`);
            instrumentations.push(new Instance(userConfig));
        }
        catch (e) {
            diag.error(e);
        }
    }
    return instrumentations;
}

const tracerProvider = new WebTracerProvider({
  resource: {
    attributes: {
      // TODO update these values with ones that make sense for your application
      [ATTR_DEPLOYMENT_ENVIRONMENT_NAME]: "production",
      [ATTR_SERVICE_NAME]: "my-website",
      [ATTR_SERVICE_VERSION]: "1.0.0",
    },
  },
  spanProcessors: [
    new BatchSpanProcessor(
      new OTLPTraceExporter({
        url: "https://ingress.us-west-2.aws.dash0.com/v1/traces",
        headers: {
          // TODO we **highly** recommend that you use an auth token with restricted permissions for
          // in-browser telemetry collection. Within the auth token settings screen, you can restrict
          // an auth token to a single dataset and **only ingesting** permissions.
          Authorization: "Bearer auth_HvdEv1AswFrSJFC2KwgvmdeZGXSE00i6",
        },
      }),
      {
        maxQueueSize: 100, // The maximum queue size. After the size is reached, spans are dropped.
        maxExportBatchSize: 10, // The maximum batch size of every export. It must be smaller or equal to maxQueueSize.
        scheduledDelayMillis: 500, // The interval between two consecutive exports
        exportTimeoutMillis: 30000, // How long the export can run before it is cancelled
      }
    ),
  ],
});

tracerProvider.register({
  // Changing default context manager to use ZoneContextManager. This one supports tracking of asynchronous operations.
  // Optional, but recommended for better correlation.
  contextManager: new ZoneContextManager(),
});

// Registering instrumentations
registerInstrumentations({
  instrumentations: [
    // You can configure all the auto-instrumentations via this function's parameter.
    // Learn more via this documentation: https://www.npmjs.com/package/@opentelemetry/auto-instrumentations-web
    getWebAutoInstrumentations(),
  ],
});
//# sourceMappingURL=instrumentation.bundle.js.map
